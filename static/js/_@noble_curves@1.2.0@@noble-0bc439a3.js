import{h as kt,c as Yt,r as jt,s as Ht}from"./_@noble_hashes@1.3.2@@noble-2e739e18.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ut=BigInt(0),ut=BigInt(1),Kt=BigInt(2),lt=n=>n instanceof Uint8Array,Mt=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function ot(n){if(!lt(n))throw new Error("Uint8Array expected");let e="";for(let t=0;t<n.length;t++)e+=Mt[n[t]];return e}function Zt(n){const e=n.toString(16);return e.length&1?"0".concat(e):e}function bt(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":"0x".concat(n))}function it(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const e=n.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const t=new Uint8Array(e/2);for(let r=0;r<t.length;r++){const i=r*2,f=n.slice(i,i+2),g=Number.parseInt(f,16);if(Number.isNaN(g)||g<0)throw new Error("Invalid byte sequence");t[r]=g}return t}function J(n){return bt(ot(n))}function Et(n){if(!lt(n))throw new Error("Uint8Array expected");return bt(ot(Uint8Array.from(n).reverse()))}function st(n,e){return it(n.toString(16).padStart(e*2,"0"))}function Bt(n,e){return st(n,e).reverse()}function Pt(n){return it(Zt(n))}function K(n,e,t){let r;if(typeof e=="string")try{r=it(e)}catch(f){throw new Error("".concat(n,' must be valid hex string, got "').concat(e,'". Cause: ').concat(f))}else if(lt(e))r=Uint8Array.from(e);else throw new Error("".concat(n," must be hex string or Uint8Array"));const i=r.length;if(typeof t=="number"&&i!==t)throw new Error("".concat(n," expected ").concat(t," bytes, got ").concat(i));return r}function ft(...n){const e=new Uint8Array(n.reduce((r,i)=>r+i.length,0));let t=0;return n.forEach(r=>{if(!lt(r))throw new Error("Uint8Array expected");e.set(r,t),t+=r.length}),e}function Gt(n,e){if(n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Ft(n){if(typeof n!="string")throw new Error("utf8ToBytes expected string, got ".concat(typeof n));return new Uint8Array(new TextEncoder().encode(n))}function Wt(n){let e;for(e=0;n>Ut;n>>=ut,e+=1);return e}function Xt(n,e){return n>>BigInt(e)&ut}const Dt=(n,e,t)=>n|(t?ut:Ut)<<BigInt(e),xt=n=>(Kt<<BigInt(n-1))-ut,ht=n=>new Uint8Array(n),At=n=>Uint8Array.from(n);function Rt(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=ht(n),i=ht(n),f=0;const g=()=>{r.fill(1),i.fill(0),f=0},s=(...w)=>t(i,r,...w),o=(w=ht())=>{i=s(At([0]),w),r=s(),w.length!==0&&(i=s(At([1]),w),r=s())},a=()=>{if(f++>=1e3)throw new Error("drbg: tried 1000 values");let w=0;const N=[];for(;w<e;){r=s();const T=r.slice();N.push(T),w+=r.length}return ft(...N)};return(w,N)=>{g(),o(w);let T;for(;!(T=N(a()));)o();return g(),T}}const Qt={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||n instanceof Uint8Array,isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,e)=>e.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function at(n,e,t={}){const r=(i,f,g)=>{const s=Qt[f];if(typeof s!="function")throw new Error('Invalid validator "'.concat(f,'", expected function'));const o=n[i];if(!(g&&o===void 0)&&!s(o,n))throw new Error("Invalid param ".concat(String(i),"=").concat(o," (").concat(typeof o,"), expected ").concat(f))};for(const[i,f]of Object.entries(e))r(i,f,!1);for(const[i,f]of Object.entries(t))r(i,f,!0);return n}const Jt=Object.freeze(Object.defineProperty({__proto__:null,bitGet:Xt,bitLen:Wt,bitMask:xt,bitSet:Dt,bytesToHex:ot,bytesToNumberBE:J,bytesToNumberLE:Et,concatBytes:ft,createHmacDrbg:Rt,ensureBytes:K,equalBytes:Gt,hexToBytes:it,hexToNumber:bt,numberToBytesBE:st,numberToBytesLE:Bt,numberToHexUnpadded:Zt,numberToVarBytesBE:Pt,utf8ToBytes:Ft,validateObject:at},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const R=BigInt(0),U=BigInt(1),D=BigInt(2),tn=BigInt(3),wt=BigInt(4),Nt=BigInt(5),qt=BigInt(8);BigInt(9);BigInt(16);function L(n,e){const t=n%e;return t>=R?t:e+t}function nn(n,e,t){if(t<=R||e<R)throw new Error("Expected power/modulo > 0");if(t===U)return R;let r=U;for(;e>R;)e&U&&(r=r*n%t),n=n*n%t,e>>=U;return r}function Y(n,e,t){let r=n;for(;e-- >R;)r*=r,r%=t;return r}function yt(n,e){if(n===R||e<=R)throw new Error("invert: expected positive integers, got n=".concat(n," mod=").concat(e));let t=L(n,e),r=e,i=R,f=U;for(;t!==R;){const s=r/t,o=r%t,a=i-f*s;r=t,t=o,i=f,f=a}if(r!==U)throw new Error("invert: does not exist");return L(i,e)}function en(n){const e=(n-U)/D;let t,r,i;for(t=n-U,r=0;t%D===R;t/=D,r++);for(i=D;i<n&&nn(i,e,n)!==n-U;i++);if(r===1){const g=(n+U)/wt;return function(o,a){const p=o.pow(a,g);if(!o.eql(o.sqr(p),a))throw new Error("Cannot find square root");return p}}const f=(t+U)/D;return function(s,o){if(s.pow(o,e)===s.neg(s.ONE))throw new Error("Cannot find square root");let a=r,p=s.pow(s.mul(s.ONE,i),t),w=s.pow(o,f),N=s.pow(o,t);for(;!s.eql(N,s.ONE);){if(s.eql(N,s.ZERO))return s.ZERO;let T=1;for(let c=s.sqr(N);T<a&&!s.eql(c,s.ONE);T++)c=s.sqr(c);const m=s.pow(p,U<<BigInt(a-T-1));p=s.sqr(m),w=s.mul(w,m),N=s.mul(N,p),a=T}return w}}function rn(n){if(n%wt===tn){const e=(n+U)/wt;return function(r,i){const f=r.pow(i,e);if(!r.eql(r.sqr(f),i))throw new Error("Cannot find square root");return f}}if(n%qt===Nt){const e=(n-Nt)/qt;return function(r,i){const f=r.mul(i,D),g=r.pow(f,e),s=r.mul(i,g),o=r.mul(r.mul(s,D),g),a=r.mul(s,r.sub(o,r.ONE));if(!r.eql(r.sqr(a),i))throw new Error("Cannot find square root");return a}}return en(n)}const on=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function sn(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=on.reduce((r,i)=>(r[i]="function",r),e);return at(n,t)}function cn(n,e,t){if(t<R)throw new Error("Expected power > 0");if(t===R)return n.ONE;if(t===U)return e;let r=n.ONE,i=e;for(;t>R;)t&U&&(r=n.mul(r,i)),i=n.sqr(i),t>>=U;return r}function fn(n,e){const t=new Array(e.length),r=e.reduce((f,g,s)=>n.is0(g)?f:(t[s]=f,n.mul(f,g)),n.ONE),i=n.inv(r);return e.reduceRight((f,g,s)=>n.is0(g)?f:(t[s]=n.mul(f,t[s]),n.mul(f,g)),i),t}function Lt(n,e){const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function an(n,e,t=!1,r={}){if(n<=R)throw new Error("Expected Field ORDER > 0, got ".concat(n));const{nBitLength:i,nByteLength:f}=Lt(n,e);if(f>2048)throw new Error("Field lengths over 2048 bytes are not supported");const g=rn(n),s=Object.freeze({ORDER:n,BITS:i,BYTES:f,MASK:xt(i),ZERO:R,ONE:U,create:o=>L(o,n),isValid:o=>{if(typeof o!="bigint")throw new Error("Invalid field element: expected bigint, got ".concat(typeof o));return R<=o&&o<n},is0:o=>o===R,isOdd:o=>(o&U)===U,neg:o=>L(-o,n),eql:(o,a)=>o===a,sqr:o=>L(o*o,n),add:(o,a)=>L(o+a,n),sub:(o,a)=>L(o-a,n),mul:(o,a)=>L(o*a,n),pow:(o,a)=>cn(s,o,a),div:(o,a)=>L(o*yt(a,n),n),sqrN:o=>o*o,addN:(o,a)=>o+a,subN:(o,a)=>o-a,mulN:(o,a)=>o*a,inv:o=>yt(o,n),sqrt:r.sqrt||(o=>g(s,o)),invertBatch:o=>fn(s,o),cmov:(o,a,p)=>p?a:o,toBytes:o=>t?Bt(o,f):st(o,f),fromBytes:o=>{if(o.length!==f)throw new Error("Fp.fromBytes: expected ".concat(f,", got ").concat(o.length));return t?Et(o):J(o)}});return Object.freeze(s)}function _t(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function zt(n){const e=_t(n);return e+Math.ceil(e/2)}function un(n,e,t=!1){const r=n.length,i=_t(e),f=zt(e);if(r<16||r<f||r>1024)throw new Error("expected ".concat(f,"-1024 bytes of input, got ").concat(r));const g=t?J(n):Et(n),s=L(g,e-U)+U;return t?Bt(s,i):st(s,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ln=BigInt(0),gt=BigInt(1);function dn(n,e){const t=(i,f)=>{const g=f.negate();return i?g:f},r=i=>{const f=Math.ceil(e/i)+1,g=2**(i-1);return{windows:f,windowSize:g}};return{constTimeNegate:t,unsafeLadder(i,f){let g=n.ZERO,s=i;for(;f>ln;)f&gt&&(g=g.add(s)),s=s.double(),f>>=gt;return g},precomputeWindow(i,f){const{windows:g,windowSize:s}=r(f),o=[];let a=i,p=a;for(let w=0;w<g;w++){p=a,o.push(p);for(let N=1;N<s;N++)p=p.add(a),o.push(p);a=p.double()}return o},wNAF(i,f,g){const{windows:s,windowSize:o}=r(i);let a=n.ZERO,p=n.BASE;const w=BigInt(2**i-1),N=2**i,T=BigInt(i);for(let m=0;m<s;m++){const c=m*o;let l=Number(g&w);g>>=T,l>o&&(l-=N,g+=gt);const d=c,b=c+Math.abs(l)-1,B=m%2!==0,I=l<0;l===0?p=p.add(t(B,f[d])):a=a.add(t(I,f[b]))}return{p:a,f:p}},wNAFCached(i,f,g,s){const o=i._WINDOW_SIZE||1;let a=f.get(i);return a||(a=this.precomputeWindow(i,o),o!==1&&f.set(i,s(a))),this.wNAF(o,a,g)}}}function Ct(n){return sn(n.Fp),at(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Lt(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function hn(n){const e=Ct(n);at(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:i}=e;if(t){if(!r.eql(i,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:gn,hexToBytes:wn}=Jt,Q={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(n){const{Err:e}=Q;if(n.length<2||n[0]!==2)throw new e("Invalid signature integer tag");const t=n[1],r=n.subarray(2,t+2);if(!t||r.length!==t)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:gn(r),l:n.subarray(t+2)}},toSig(n){const{Err:e}=Q,t=typeof n=="string"?wn(n):n;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let r=t.length;if(r<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:i,l:f}=Q._parseInt(t.subarray(2)),{d:g,l:s}=Q._parseInt(f);if(s.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s:g}},hexFromSig(n){const e=a=>Number.parseInt(a[0],16)&8?"00"+a:a,t=a=>{const p=a.toString(16);return p.length&1?"0".concat(p):p},r=e(t(n.s)),i=e(t(n.r)),f=r.length/2,g=i.length/2,s=t(f),o=t(g);return"30".concat(t(g+f+4),"02").concat(o).concat(i,"02").concat(s).concat(r)}},M=BigInt(0),j=BigInt(1);BigInt(2);const Ot=BigInt(3);BigInt(4);function yn(n){const e=hn(n),{Fp:t}=e,r=e.toBytes||((m,c,l)=>{const d=c.toAffine();return ft(Uint8Array.from([4]),t.toBytes(d.x),t.toBytes(d.y))}),i=e.fromBytes||(m=>{const c=m.subarray(1),l=t.fromBytes(c.subarray(0,t.BYTES)),d=t.fromBytes(c.subarray(t.BYTES,2*t.BYTES));return{x:l,y:d}});function f(m){const{a:c,b:l}=e,d=t.sqr(m),b=t.mul(d,m);return t.add(t.add(b,t.mul(m,c)),l)}if(!t.eql(t.sqr(e.Gy),f(e.Gx)))throw new Error("bad generator point: equation left != right");function g(m){return typeof m=="bigint"&&M<m&&m<e.n}function s(m){if(!g(m))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function o(m){const{allowedPrivateKeyLengths:c,nByteLength:l,wrapPrivateKey:d,n:b}=e;if(c&&typeof m!="bigint"){if(m instanceof Uint8Array&&(m=ot(m)),typeof m!="string"||!c.includes(m.length))throw new Error("Invalid key");m=m.padStart(l*2,"0")}let B;try{B=typeof m=="bigint"?m:J(K("private key",m,l))}catch(I){throw new Error("private key must be ".concat(l," bytes, hex or bigint, not ").concat(typeof m))}return d&&(B=L(B,b)),s(B),B}const a=new Map;function p(m){if(!(m instanceof w))throw new Error("ProjectivePoint expected")}class w{constructor(c,l,d){if(this.px=c,this.py=l,this.pz=d,c==null||!t.isValid(c))throw new Error("x required");if(l==null||!t.isValid(l))throw new Error("y required");if(d==null||!t.isValid(d))throw new Error("z required")}static fromAffine(c){const{x:l,y:d}=c||{};if(!c||!t.isValid(l)||!t.isValid(d))throw new Error("invalid affine point");if(c instanceof w)throw new Error("projective point not allowed");const b=B=>t.eql(B,t.ZERO);return b(l)&&b(d)?w.ZERO:new w(l,d,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(c){const l=t.invertBatch(c.map(d=>d.pz));return c.map((d,b)=>d.toAffine(l[b])).map(w.fromAffine)}static fromHex(c){const l=w.fromAffine(i(K("pointHex",c)));return l.assertValidity(),l}static fromPrivateKey(c){return w.BASE.multiply(o(c))}_setWindowSize(c){this._WINDOW_SIZE=c,a.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:c,y:l}=this.toAffine();if(!t.isValid(c)||!t.isValid(l))throw new Error("bad point: x or y not FE");const d=t.sqr(l),b=f(c);if(!t.eql(d,b))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:c}=this.toAffine();if(t.isOdd)return!t.isOdd(c);throw new Error("Field doesn't support isOdd")}equals(c){p(c);const{px:l,py:d,pz:b}=this,{px:B,py:I,pz:S}=c,y=t.eql(t.mul(l,S),t.mul(B,b)),E=t.eql(t.mul(d,S),t.mul(I,b));return y&&E}negate(){return new w(this.px,t.neg(this.py),this.pz)}double(){const{a:c,b:l}=e,d=t.mul(l,Ot),{px:b,py:B,pz:I}=this;let S=t.ZERO,y=t.ZERO,E=t.ZERO,v=t.mul(b,b),k=t.mul(B,B),$=t.mul(I,I),A=t.mul(b,B);return A=t.add(A,A),E=t.mul(b,I),E=t.add(E,E),S=t.mul(c,E),y=t.mul(d,$),y=t.add(S,y),S=t.sub(k,y),y=t.add(k,y),y=t.mul(S,y),S=t.mul(A,S),E=t.mul(d,E),$=t.mul(c,$),A=t.sub(v,$),A=t.mul(c,A),A=t.add(A,E),E=t.add(v,v),v=t.add(E,v),v=t.add(v,$),v=t.mul(v,A),y=t.add(y,v),$=t.mul(B,I),$=t.add($,$),v=t.mul($,A),S=t.sub(S,v),E=t.mul($,k),E=t.add(E,E),E=t.add(E,E),new w(S,y,E)}add(c){p(c);const{px:l,py:d,pz:b}=this,{px:B,py:I,pz:S}=c;let y=t.ZERO,E=t.ZERO,v=t.ZERO;const k=e.a,$=t.mul(e.b,Ot);let A=t.mul(l,B),_=t.mul(d,I),z=t.mul(b,S),P=t.add(l,d),u=t.add(B,I);P=t.mul(P,u),u=t.add(A,_),P=t.sub(P,u),u=t.add(l,b);let h=t.add(B,S);return u=t.mul(u,h),h=t.add(A,z),u=t.sub(u,h),h=t.add(d,b),y=t.add(I,S),h=t.mul(h,y),y=t.add(_,z),h=t.sub(h,y),v=t.mul(k,u),y=t.mul($,z),v=t.add(y,v),y=t.sub(_,v),v=t.add(_,v),E=t.mul(y,v),_=t.add(A,A),_=t.add(_,A),z=t.mul(k,z),u=t.mul($,u),_=t.add(_,z),z=t.sub(A,z),z=t.mul(k,z),u=t.add(u,z),A=t.mul(_,u),E=t.add(E,A),A=t.mul(h,u),y=t.mul(P,y),y=t.sub(y,A),A=t.mul(P,_),v=t.mul(h,v),v=t.add(v,A),new w(y,E,v)}subtract(c){return this.add(c.negate())}is0(){return this.equals(w.ZERO)}wNAF(c){return T.wNAFCached(this,a,c,l=>{const d=t.invertBatch(l.map(b=>b.pz));return l.map((b,B)=>b.toAffine(d[B])).map(w.fromAffine)})}multiplyUnsafe(c){const l=w.ZERO;if(c===M)return l;if(s(c),c===j)return this;const{endo:d}=e;if(!d)return T.unsafeLadder(this,c);let{k1neg:b,k1:B,k2neg:I,k2:S}=d.splitScalar(c),y=l,E=l,v=this;for(;B>M||S>M;)B&j&&(y=y.add(v)),S&j&&(E=E.add(v)),v=v.double(),B>>=j,S>>=j;return b&&(y=y.negate()),I&&(E=E.negate()),E=new w(t.mul(E.px,d.beta),E.py,E.pz),y.add(E)}multiply(c){s(c);let l=c,d,b;const{endo:B}=e;if(B){const{k1neg:I,k1:S,k2neg:y,k2:E}=B.splitScalar(l);let{p:v,f:k}=this.wNAF(S),{p:$,f:A}=this.wNAF(E);v=T.constTimeNegate(I,v),$=T.constTimeNegate(y,$),$=new w(t.mul($.px,B.beta),$.py,$.pz),d=v.add($),b=k.add(A)}else{const{p:I,f:S}=this.wNAF(l);d=I,b=S}return w.normalizeZ([d,b])[0]}multiplyAndAddUnsafe(c,l,d){const b=w.BASE,B=(S,y)=>y===M||y===j||!S.equals(b)?S.multiplyUnsafe(y):S.multiply(y),I=B(this,l).add(B(c,d));return I.is0()?void 0:I}toAffine(c){const{px:l,py:d,pz:b}=this,B=this.is0();c==null&&(c=B?t.ONE:t.inv(b));const I=t.mul(l,c),S=t.mul(d,c),y=t.mul(b,c);if(B)return{x:t.ZERO,y:t.ZERO};if(!t.eql(y,t.ONE))throw new Error("invZ was invalid");return{x:I,y:S}}isTorsionFree(){const{h:c,isTorsionFree:l}=e;if(c===j)return!0;if(l)return l(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:c,clearCofactor:l}=e;return c===j?this:l?l(w,this):this.multiplyUnsafe(e.h)}toRawBytes(c=!0){return this.assertValidity(),r(w,this,c)}toHex(c=!0){return ot(this.toRawBytes(c))}}w.BASE=new w(e.Gx,e.Gy,t.ONE),w.ZERO=new w(t.ZERO,t.ONE,t.ZERO);const N=e.nBitLength,T=dn(w,e.endo?Math.ceil(N/2):N);return{CURVE:e,ProjectivePoint:w,normPrivateKeyToScalar:o,weierstrassEquation:f,isWithinCurveOrder:g}}function pn(n){const e=Ct(n);return at(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function mn(n){const e=pn(n),{Fp:t,n:r}=e,i=t.BYTES+1,f=2*t.BYTES+1;function g(u){return M<u&&u<t.ORDER}function s(u){return L(u,r)}function o(u){return yt(u,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:p,weierstrassEquation:w,isWithinCurveOrder:N}=yn({...e,toBytes(u,h,x){const O=h.toAffine(),q=t.toBytes(O.x),Z=ft;return x?Z(Uint8Array.from([h.hasEvenY()?2:3]),q):Z(Uint8Array.from([4]),q,t.toBytes(O.y))},fromBytes(u){const h=u.length,x=u[0],O=u.subarray(1);if(h===i&&(x===2||x===3)){const q=J(O);if(!g(q))throw new Error("Point is not on curve");const Z=w(q);let C=t.sqrt(Z);const V=(C&j)===j;return(x&1)===1!==V&&(C=t.neg(C)),{x:q,y:C}}else if(h===f&&x===4){const q=t.fromBytes(O.subarray(0,t.BYTES)),Z=t.fromBytes(O.subarray(t.BYTES,2*t.BYTES));return{x:q,y:Z}}else throw new Error("Point of length ".concat(h," was invalid. Expected ").concat(i," compressed bytes or ").concat(f," uncompressed bytes"))}}),T=u=>ot(st(u,e.nByteLength));function m(u){const h=r>>j;return u>h}function c(u){return m(u)?s(-u):u}const l=(u,h,x)=>J(u.slice(h,x));class d{constructor(h,x,O){this.r=h,this.s=x,this.recovery=O,this.assertValidity()}static fromCompact(h){const x=e.nByteLength;return h=K("compactSignature",h,x*2),new d(l(h,0,x),l(h,x,2*x))}static fromDER(h){const{r:x,s:O}=Q.toSig(K("DER",h));return new d(x,O)}assertValidity(){if(!N(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!N(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(h){return new d(this.r,this.s,h)}recoverPublicKey(h){const{r:x,s:O,recovery:q}=this,Z=E(K("msgHash",h));if(q==null||![0,1,2,3].includes(q))throw new Error("recovery id invalid");const C=q===2||q===3?x+e.n:x;if(C>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const V=q&1?"03":"02",G=a.fromHex(V+T(C)),F=o(C),tt=s(-Z*F),ct=s(O*F),W=a.BASE.multiplyAndAddUnsafe(G,tt,ct);if(!W)throw new Error("point at infinify");return W.assertValidity(),W}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return it(this.toDERHex())}toDERHex(){return Q.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return it(this.toCompactHex())}toCompactHex(){return T(this.r)+T(this.s)}}const b={isValidPrivateKey(u){try{return p(u),!0}catch(h){return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{const u=zt(e.n);return un(e.randomBytes(u),e.n)},precompute(u=8,h=a.BASE){return h._setWindowSize(u),h.multiply(BigInt(3)),h}};function B(u,h=!0){return a.fromPrivateKey(u).toRawBytes(h)}function I(u){const h=u instanceof Uint8Array,x=typeof u=="string",O=(h||x)&&u.length;return h?O===i||O===f:x?O===2*i||O===2*f:u instanceof a}function S(u,h,x=!0){if(I(u))throw new Error("first arg must be private key");if(!I(h))throw new Error("second arg must be public key");return a.fromHex(h).multiply(p(u)).toRawBytes(x)}const y=e.bits2int||function(u){const h=J(u),x=u.length*8-e.nBitLength;return x>0?h>>BigInt(x):h},E=e.bits2int_modN||function(u){return s(y(u))},v=xt(e.nBitLength);function k(u){if(typeof u!="bigint")throw new Error("bigint expected");if(!(M<=u&&u<v))throw new Error("bigint expected < 2^".concat(e.nBitLength));return st(u,e.nByteLength)}function $(u,h,x=A){if(["recovered","canonical"].some(X=>X in x))throw new Error("sign() legacy options not supported");const{hash:O,randomBytes:q}=e;let{lowS:Z,prehash:C,extraEntropy:V}=x;Z==null&&(Z=!0),u=K("msgHash",u),C&&(u=K("prehashed msgHash",O(u)));const G=E(u),F=p(h),tt=[k(F),k(G)];if(V!=null){const X=V===!0?q(t.BYTES):V;tt.push(K("extraEntropy",X))}const ct=ft(...tt),W=G;function dt(X){const nt=y(X);if(!N(nt))return;const vt=o(nt),et=a.BASE.multiply(nt).toAffine(),H=s(et.x);if(H===M)return;const rt=s(vt*s(W+H*F));if(rt===M)return;let St=(et.x===H?0:2)|Number(et.y&j),It=rt;return Z&&m(rt)&&(It=c(rt),St^=1),new d(H,It,St)}return{seed:ct,k2sig:dt}}const A={lowS:e.lowS,prehash:!1},_={lowS:e.lowS,prehash:!1};function z(u,h,x=A){const{seed:O,k2sig:q}=$(u,h,x),Z=e;return Rt(Z.hash.outputLen,Z.nByteLength,Z.hmac)(O,q)}a.BASE._setWindowSize(8);function P(u,h,x,O=_){var et;const q=u;if(h=K("msgHash",h),x=K("publicKey",x),"strict"in O)throw new Error("options.strict was renamed to lowS");const{lowS:Z,prehash:C}=O;let V,G;try{if(typeof q=="string"||q instanceof Uint8Array)try{V=d.fromDER(q)}catch(H){if(!(H instanceof Q.Err))throw H;V=d.fromCompact(q)}else if(typeof q=="object"&&typeof q.r=="bigint"&&typeof q.s=="bigint"){const{r:H,s:rt}=q;V=new d(H,rt)}else throw new Error("PARSE");G=a.fromHex(x)}catch(H){if(H.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(Z&&V.hasHighS())return!1;C&&(h=e.hash(h));const{r:F,s:tt}=V,ct=E(h),W=o(tt),dt=s(ct*W),X=s(F*W),nt=(et=a.BASE.multiplyAndAddUnsafe(G,dt,X))==null?void 0:et.toAffine();return nt?s(nt.x)===F:!1}return{CURVE:e,getPublicKey:B,getSharedSecret:S,sign:z,verify:P,ProjectivePoint:a,Signature:d,utils:b}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function bn(n){return{hash:n,hmac:(e,...t)=>kt(n,e,Yt(...t)),randomBytes:jt}}function En(n,e){const t=r=>mn({...n,...bn(r)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),$t=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Bn=BigInt(1),pt=BigInt(2),Tt=(n,e)=>(n+e/pt)/e;function xn(n){const e=Vt,t=BigInt(3),r=BigInt(6),i=BigInt(11),f=BigInt(22),g=BigInt(23),s=BigInt(44),o=BigInt(88),a=n*n*n%e,p=a*a*n%e,w=Y(p,t,e)*p%e,N=Y(w,t,e)*p%e,T=Y(N,pt,e)*a%e,m=Y(T,i,e)*T%e,c=Y(m,f,e)*m%e,l=Y(c,s,e)*c%e,d=Y(l,o,e)*l%e,b=Y(d,s,e)*c%e,B=Y(b,t,e)*p%e,I=Y(B,g,e)*m%e,S=Y(I,r,e)*a%e,y=Y(S,pt,e);if(!mt.eql(mt.sqr(y),n))throw new Error("Cannot find square root");return y}const mt=an(Vt,void 0,void 0,{sqrt:xn}),vn=En({a:BigInt(0),b:BigInt(7),Fp:mt,n:$t,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=$t,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Bn*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),f=t,g=BigInt("0x100000000000000000000000000000000"),s=Tt(f*n,e),o=Tt(-r*n,e);let a=L(n-s*t-o*i,e),p=L(-s*r-o*f,e);const w=a>g,N=p>g;if(w&&(a=e-a),N&&(p=e-p),a>g||p>g)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:w,k1:a,k2neg:N,k2:p}}}},Ht);BigInt(0);vn.ProjectivePoint;export{vn as s};
