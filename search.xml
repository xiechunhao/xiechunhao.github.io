<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[入门webpack,这篇就够了]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%85%A5%E9%97%A8webpack%2C%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[1: 写在前面的话阅读本文之前，先看下面这个webpack的配置文件，如果每一项你都懂，那本文能带给你的收获也许就比较有限，你可以快速浏览或直接跳过；如果你和十天前的我一样，对很多选项存在着疑惑，那花一段时间慢慢阅读本文，你的疑惑一定一个一个都会消失；如果你以前没怎么接触过Webpack，而你又你对webpack感兴趣，那么动手跟着本文中那个贯穿始终的例子写一次，写完以后你会发现你已明明白白的走进了Webpack的大门。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 一个常见的`webpack`配置文件const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry:&#123; app:'./src/main.js',//已多次提及的唯一入口文件 &#125;, // 或者 entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/build", filename: "bundle-[hash].js" &#125;, devtool: 'none', devServer: &#123; contentBase: "./public", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true, hot: true &#125;, module: &#123; rules: [&#123; test: /(\.jsx|\.js)$/, use: &#123; loader: "babel-loader" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: "style-loader", use: [&#123; loader: "css-loader", options: &#123; modules: true, localIdentName: '[name]__[local]--[hash:base64:5]' &#125; &#125;, &#123; loader: "postcss-loader" &#125;], &#125;) &#125; &#125; ] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + "/app/index.tmpl.html" //new 一个这个插件的实例，并传入相关的参数 &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin(), new ExtractTextPlugin("style.css") ]&#125;;2: webpack是什么，为什么要使用它2.1: 什么是 webpackWebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。2.2: 为什么要使用它现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法。模块化，让我们可以把复杂的程序细化为小的文件;类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；Scss，less等CSS预处理器…这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。3: 开始使用 webpack初步了解了Webpack工作方式后，我们一步步的开始学习使用Webpack。3.1: 安装Webpack可以使用npm安装，新建一个空的练习文件夹（此处命名为 webpack-demo），在终端中转到该文件夹后执行下述指令就可以完成安装。1234//全局安装npm install -g webpack//安装到你的项目目录npm install --save-dev webpack3.2: 使用前准备在上述练习文件夹中创建一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用npm init命令可以自动创建这个package.json文件1npm init输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过不用担心，如果你不准备在npm中发布你的模块，这些问题的答案都不重要，回车默认即可。package.json文件已经就绪，我们在本项目中安装Webpack作为依赖包12// 安装Webpackcnpm install --save-dev webpack回到之前的空文件夹，并在里面创建两个文件夹,src文件夹和dist文件夹，src文件夹用来存放原静态资源，dist文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js）。接下来我们再创建三个文件:css –放在src文件夹中;images– 放在src文件夹中;js– 放在src文件夹中;index.html–写基本的html结构main–写main入口js代码此时目录结构如下：我们在index.html文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们先把之后打包后的js文件命名为bundle.js，之后我们还会详细讲述）。1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="../dist/bundle.js"&gt;&lt;/script&gt; &lt;ul&gt; &lt;li&gt;11*10&lt;/li&gt; &lt;li&gt;21*10&lt;/li&gt; &lt;li&gt;31*10&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;main.js文件中我们写入下述代码。1234567// 由于 ES6的代码，太高级了，浏览器解析不了，所以，这一行执行会报错import $ from 'jquery';$(function()&#123; $('li:odd').css('backgroundColor','red'); $('li:even').css('backgroundColor','yellow');&#125;);直接在页面上引用main.js会报错，因为浏览器不认识 import 这种 es6 高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；需要安装 webpack-cli。1npm install webpack webpack-cli --save-dev4: 正式使用 webpack因为上面用了 jQuery，所以我们需要安装下1cnpm install jquery --savewebpack可以在终端中使用，在基本的使用方法如下：123456// &#123;extry file&#125;出填写入口文件的路径，本文中就是上述main.js的路径，// &#123;destination for bundled file&#125;处填写打包文件的存放路径// 填写路径的时候不用添加&#123;&#125;webpack &#123;entry file&#125; &#123;destination for bundled file&#125; # 如下webpack src/js/main.js --output dist/bundle.js运行完此时可以看到 dist/bundle.js 会自动生成编译好的代码，可以看出webpack编译了main.js 现在右键打开index.html,可以看到如下结果有没有很激动，已经成功的使用Webpack打包了一个文件了。不过在终端中进行复杂的操作，其实是不太方便且容易出错的，接下来看看Webpack的另一种更常见的使用方法。5: 通过配置使用 webpack 启动项目Webpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如前面提到的，这样不太方便且容易出错的，更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，我们可以把所有的与打包相关的信息放在里面。继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，我们在其中写入如下所示的简单配置代码，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。12345678910111213// 导入处理路径的模块const path = require('path')// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; entry:&#123; app:'./src/main.js' &#125;, output: &#123; // 配置输出选项 path:path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;&#125;注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。有了这个配置之后，再打包文件，只需在终端里运行webpack(非全局安装需使用node_modules/.bin/webpack)命令就可以了，这条命令会自动引用webpack.config.js文件中的配置选项，示例如下：又学会了一种使用Webpack的方法，这种方法不用管那烦人的命令行参数，有没有感觉很爽。如果我们可以连webpack(非全局安装需使用node_modules/.bin/webpack)这条命令都可以不用，那种感觉会不会更爽~，继续看下文。6: 使用更快捷方式执行 webpack在命令行中输入命令需要代码类似于node_modules/.bin/webpack这样的路径其实是比较烦人的，不过值得庆幸的是npm可以引导任务执行，对npm进行配置后可以在命令行中使用简单的npm start命令来替代上面略微繁琐的命令。在package.json中对scripts对象进行相关设置即可，设置方法如下。123456&#123; "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "webpack" // 修改的是这里，JSON文件不支持注释，引用时请清除 &#125;,&#125;注：package.json中的script会安装一定顺序寻找命令对应位置，本地的node_modules/.bin路径就在这个寻找清单中，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build，我们在命令行中输入npm start试试，输出结果如下：现在只需要使用npm start就可以打包文件了，有没有觉得webpack也不过如此嘛，不过不要太小瞧webpack，要充分发挥其强大的功能我们需要修改配置文件的其它选项，一项项来看。7: 使用 webpack 构建本地服务器想不想让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖1npm install --save-dev webpack-dev-serverdevserver作为webpack配置选项中的一项，以下是它的一些配置选项，更多配置可参考这里devserver的配置选项功能描述contentBase默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）port设置默认监听端口，如果省略，默认为”8080“inline设置为true，当源文件改变时会自动刷新页面historyApiFallback在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示12345devServer: &#123; contentBase: "./dist",//本地服务器所加载的页面所在的目录 hot:true, inline: true//实时刷新&#125;12345"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "webpack", "server": "webpack-dev-server --open --contentBase src" // 修改的是这里，JSON文件不支持注释，引用时请清除 &#125;,在终端中输入npm run server即可在本地的8080端口查看结果。注：需要修改 index.html 下面的 bundle.js路径为 &lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt;8: 管理资源注： webpack 只能识别 JS 文件，其他外部文件需要 安装对应的 loader 文件去做解析8.1: 加载 css为了在 JavaScript 模块中 import 一个 CSS 文件，你需要安装 style-loader 和 css-loader，并在 module 配置 中添加这些 loader：1npm install --save-dev style-loader css-loaderwebpack.config.js123456789module: &#123;// 用来配置第三方loader模块的 rules: [&#123;// 文件的匹配规则 test: /.css$/, use: [//处理css文件的规则 &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125;]&#125;webpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。在这个示例中，所有以 .css 结尾的文件，都将被提供给 style-loader 和 css-loader。我们尝试一下，通过在项目中添加一个新的 index.css 文件，并将其 import 到我们的 index.js 中：1234html body &#123; background: #666; padding: 50px;&#125;main.js 导入css文件1import './css/index.css';现在运行 npm run server 命令：就可以看到 css 设置的样式8.2: 加载 less /sassless / sass 的 使用 跟 css 类似，先 npm 安装12cnpm install less-loader less -Dcnpm install sass-loader node-sass -save-dev在配置 webpack.config.js 匹配规则123456789101112module: &#123; // 用来配置第三方loader模块的 rules: [ &#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, //处理less文件的规则 &#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, //处理scss文件的规则 ]&#125;index.less12345html&#123; body&#123; background-color: hotpink; &#125;&#125;index.scss12345html&#123; body&#123; color: goldenrod; &#125;&#125;main.js12import './css/index.less';import './css/index.sass';运行 npm run server 命令即可看下效果8.3: 加载 images 图片先 npm 安装图片的 loader1cnpm install --save-dev file-loader在配置 webpack.config.js 匹配规则12345678910module: &#123; // 用来配置第三方loader模块的 rules: [ &#123; test: /\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125; ]&#125;src 文件夹下images 文件下，添加一张图片，在 index.html 页面添加 div设置 id 为 img在 index.css 文件中设置背景图样式：如下123456#img&#123; background-image: url('../images/八神庵.png'); width: 200px; height: 200px; background-color: bisque;&#125;运行 npm run server 命令即可看下效果8.4: 加载 font 字体]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 递归的深入理解]]></title>
    <url>%2F2019%2F03%2F04%2F%E9%80%92%E5%BD%92%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1: 递归 : 在函数内调用函数自己自己调用自己结束的条件了解函数在调用的时候才会占用内存, 不调用不会占内存没有递归结束条件的递归就是死递归 会出现堆溢出.2: 递归的优缺点:优点代码简洁在树的前序，中序，后序遍历算法中，递归的实现明显要比循环简单得多。缺点递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。-&gt;效率递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分，则存在重复计算，如fibonacci斐波那契数列的递归实现。-&gt; 效率调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。-&gt;性能3: 实例:3.1: 递归实现累计求和:12345678function getSum(n) &#123; if(n == 1)&#123; return 1; &#125;else&#123; return n + getSum(n-1); &#125; &#125;console.log(getSum(10)); //553.2: 递归实现阶乘:12345678function getChen(n) &#123; if(n == 1)&#123; return 1; &#125;else&#123; return n * getChen(n-1); &#125;&#125;console.log(getChen(5)); //120 5*4*3*2*13.3: 斐波那契求第N位数的值:出现重复计算: 内存消耗12345678 function feiBo(n) &#123; if(n == 1 || n == 2)&#123; return 1; &#125;else &#123; return feiBo(n-2) + feiBo(n-1); &#125; &#125;console.log(feiBo(10));3.4: 递归常用在遍历DOM树下面的所有元素12345678910111213141516//需求：获取id为father元素的所有后代元素//dom中有没有直接的api可以获取呢？ 没有，只能自己封装函数实现/*思路1.写一个函数，遍历这个元素的childred子元素，获取它的子元素2.让它的每一个子元素继续调用这个函数，遍历子元素的子元素，形成递归调用 */var father = document.getElementById('father');var list = [];function houDai(ele) &#123; for (var i = 0; i &lt; ele.children.length; i++) &#123; list.push(ele.children[i]); houDai(ele.children[i]); &#125;&#125;houDai(father);console.log(list);面试题阶乘，求res值?1var res = (function (n) &#123;return n == 1 ? 1 : n * arguments.callee(n-1)&#125;)(5);解析: 就是递归阶乘. arguments.callee()是获取匿名函数的函数名.因为是匿名函数只能通过这样才能获取实现递归��归]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的接口API]]></title>
    <url>%2F2019%2F03%2F04%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3API%2F</url>
    <content type="text"><![CDATA[1: 网易云接口文档 API1https://binaryify.github.io/NeteaseCloudMusicApi/#/]]></content>
      <categories>
        <category>第三方接口</category>
      </categories>
      <tags>
        <tag>API接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm 介绍及常用命令]]></title>
    <url>%2F2019%2F03%2F04%2Fnpm%20%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[npm 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径，只要电脑安装了 node 就 安装了 npm 包管理工具1: npm 官网地址1https://www.npmjs.com/2: npm常用命令123456789npm install --global npm // 自己升级自己npm init // 项目初始化npm init -y // 可以直接跳过向导，快速生成npm install // 一次性把dependencies选项中的依赖项全部安装npm install 包名 //下载包名npm install --save 包名 //下载并保存依赖项，（package.json文件中的dependenice选项）npm uninstall 包名 //只删除，如果有依赖选会依然保存npm uninstall --save 包名 //删除的同时会把依赖的信息也去除npm help //查看使用帮助3: 安装慢或者被墙问题解决办法npm存储包文件的服务器在国外，有时候会被墙，速度很慢，所以我们需要解决这个问题http://npm.taobao.org/：淘宝的开发团队吧npm在国内做了一个备份，每10分钟会被备份一次所以我们安装淘宝的cnpm1npm install --global npm接下来你安装包的时候把之前的npm替换成cnpm既可：举列如下12345//这个是走国外的服务器，速度比较慢npm install jquery//使用cnpm 就是走淘宝服务器，速度比较快。cnpm install jquery如果不想安装cnpm又想使用淘宝的服务器来下载：123npm config set registry=https://registry.npm.taobao.org//查看npm配置文件npm config list]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快递单号接口API]]></title>
    <url>%2F2019%2F03%2F04%2F%E5%BF%AB%E9%80%92%E5%8D%95%E5%8F%B7%E6%8E%A5%E5%8F%A3API%2F</url>
    <content type="text"><![CDATA[1: 应用场景：物流信息查询2: 本接口采用的是聚合数据接口1https://www.juhe.cn/docs/api/id/433: 注册账号申请快递单号接口：获取申请的key4: 接口参数查看（主要是这三个需要传到服务端）5: Demo 代码12345678910111213141516171819&lt;!-- Jquery保证在1.12及以上 --&gt;&lt;script src="./jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;script&gt; var $key = "870967b6f718e99ceda764f1829c1763"; //申请的商户ID var $kdNumber = "3383748328872"; //快递单号 var $com = "sto"; //快递物流公司简称 如：STO申通 SF顺风等 $.get(&#123; url:'http://v.juhe.cn/exp/index', data:&#123; key : $key, com : $com, no : $kdNumber &#125;, dataType:"jsonp", success:function(data)&#123; console.log(data); &#125; &#125;);&lt;/script&gt;使用JQuery的Ajax访问（经测试直接访问获取不到数据，因为服务端没有主动设置开放CROS资源共享）浏览器会默认同源策略，所以访问失败。需要设 dataType = “jsonp” 跨域访问。返回成果的物流信息6: 查看聚合数据支持的哪些快递公司的查询1https://www.juhe.cn/box/index/id/43]]></content>
      <categories>
        <category>第三方接口</category>
      </categories>
      <tags>
        <tag>API接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 闭包的深入理解]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%97%AD%E5%8C%85%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1: JS中什么是闭包 ？就是函数 （闭包是一个可以获取其他函数内部变量的函数）2: 闭包作用延长生命周期在函数外部要想访问或者修改数据,只能通过函数的内部的方法设置安全措施,校验之内的操作,可以保证系统的安全性和稳定性3: 闭包语法函数内部声明一个闭包函数在闭包函数中返回想要访问的局部变量返回闭包函数4: 闭包本质：函数内部与函数外部连接起来的一座桥梁5: 闭包的原理上级作用域无法访问下级的作用域6: 闭包要解决的问题闭包内的数据不允许外界访问要解决的问题就是间接的访问该数据7: 闭包的实际应用场景12345678910111213141516171819202122/*闭包实际开发应用场景 -----沙箱模式 ： 一种独立的内存空间，通常是匿名函数自调用 a.提供不同的作用域---避免全局变量污染 b.模块化开发----不同的功能对应不同的作用域 */(function ( w ) &#123; var p = &#123; name:&apos;张三&apos;, sayHi:function ( ) &#123; console.log ( &quot;今天学到好多东西&quot; ); &#125; &#125;; var num = 10; //沙箱模式中所有的变量都是局部的，如何可以在外部全局变量中访问？ //将需要暴露外部的api作为window的属性 /*这里为什么不直接使用window而使用形参来接收呢？ 1.沙箱内部不能直接访问外部变量，会破坏封装性 2.以后的开发中为了减少js文件的大小，会使用专业的压缩工具来压缩,为了避免压缩工具压缩代码导致错误， 通常不直接使用window */ w.p = p;&#125;)(window);console.log ( p );//window.person8: 简单的闭包实例获取或者修改数据获取多个数据和修改多个数据9: 闭包经典面试题9.1: 求 this 的指向1234567891011121314// 返回: Window Name，调用person.getName() 返回值是一个匿名函数，此时在全局作用域中调用匿名函数，此时this指向windowvar name = 'Window Name';var person = &#123; name:'Object Name', getName:function ( ) &#123; return function ( ) &#123; return this.name; &#125; &#125;&#125;;// var fn = person.getName();// fn();console.log ( person.getName () () );//Window Name12345678910111213// 调用person.getName(),在getName方法中this指向person。此时用一个句变量that存储this（person），返回一个匿名函数，函数中that指向personvar name = 'Window Name';var person = &#123; name:'Object Name', getName:function ( ) &#123; var that = this; return function ( ) &#123; return that.name; &#125; &#125;&#125;;console.log ( person.getName () () );//Object Name9.2: 使用闭包来计算数组递归:(高性能)12345678910111213function feiBo() &#123; var arr = [1,1,0]; function closoure(n) &#123; for (var i = 2; i &lt; n; i++) &#123; arr[2] = arr[0] + arr[1]; arr[0] = arr[1]; arr[1] = arr[2]; &#125; return arr[2]; &#125; return closoure;&#125;console.log(feiBo()(10));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用（二） 配置 pure 主题样式]]></title>
    <url>%2F2017%2F05%2F27%2Fhexo%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%20%E9%85%8D%E7%BD%AE%20pure%20%E4%B8%BB%E9%A2%98%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[配置 hexo pure 主题样式详解（后续补充更多样式）1: hexo 主题使用的是：hexo-theme-pure1.1: 克隆主题并剪切到 \hexo\themes 文件夹下1git clone git@github.com:cofess/hexo-theme-pure.git1.2: 配置 使用 hexo-theme-pure 主题，在站点配置文件_config.yml中修改以下文件1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-pure2: 配置hexo 的 pure 主题注意点2.1: 编辑文件全程使用 sublime 编辑，不要用记事本打开，不会出现乱码的情况，相信搭建都知道原因2.2: 编辑文件基本都是两个文件（注意下面配置说明配置哪个文件，不要错了）配置站点文件 _config.yml配置主题文件 _config.yml3: 解决中文乱码问题在站点配置文件_config.yml中添加1language: zh-CN4: 文章设置属性（Typora 编辑 md 文件）打开需要编辑的文章12345678---title: 文章标题date: 2017-05-27 13:47:40 // 设置文件发布时间（默认是当前时间）categories: // 设置文章分类- 分类名称tags: // 设置文章标签- 标签名称toc: true //是否启用文字目录5: 分类 标签 项目 书单 友链 关于设置（C:\hexo\source）12345678910111213// 使每个目录都有自己的功能title: 分类 // 标题 date: 2019-02-28 23:56:22 // 时间layout: categories // 输出类型type: categories // 类别// 目录结构分类：categories标签：tags项目：repository书单：books友链：links关于：about6: 友链的编辑（C:\hexo\source_data\links.yml）123456789// links创造狮: link: http://chuangzaoshi.com/ avatar: /images/favatar/chuangzaoshi-logo.png desc: 为创意工作者而设计腾讯设计导航: link: http://idesign.qq.com/ avatar: /images/favatar/idesign-logo.png desc: 网罗全网高逼格的设计站点7: 搜索功能7.1: 安装1npm i hexo-generator-json-content --save7.2: 主题设置123search: insight: true # you need to install `hexo-generator-json-content` before using Insight Search baidu: true # you need to disable other search engines to use Baidu search8: 文字字数，阅读时长8.1: 安装1$ npm install hexo-wordcount --save8.2: 主题设置12345# wordcountpostCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计9: 评论功能12参考：https://blog.csdn.net/blue_zy/article/details/79071414参考：https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud10: 主题背景特效背景动画 基于canvas，在\themes\pure\layout\layout.ejs的中面添加1&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;11: 阅读次数统计本来想用leancloud来统计，因为不蒜子不能管理相关博文的阅读量，但是配置完leancloud会报错~..~只能选用不蒜子，在主题配置文件 中把busuanzi设置为true即可：123pv: busuanzi: enable: true # 不蒜子统计12: hexo-adminGithub：https://github.com/jaredly/hexo-admin简介：可以直接在网页端创建、编辑markdown文章内容，并将内容发布到_posts里。最方便的是可以很方便的给文章加标题、分类、打标签。12.1: 安装这个插件需要升级npm，先升级1npm install -g npm12.2: 然后安装1npm install --save hexo-admin12.3: 配置：在站点配置文件 _config.yml中添加1234admin: username: myfavoritename password_hash: be121740bf988b2225a313fa1f107ca1 secret: a secret something这个配置可以直接在admin Settings &gt; Setup authentification 页面中输入数据获取，secret是用于产生cookie值的。13: hexo-wordcount简介：为文章添加文章字数统计、文章预计阅读时间13.1: 安装：1npm install hexo-wordcount --save13.2: 配置：在主题配置文件 中设置为true：12345# wordcountpostCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计14: hexo-neatGithub：https://github.com/rozbo/hexo-neat简介：自动压缩html、css、js代码14.1: 安装：1npm install hexo-neat --save14.2: 配置：在站点配置文件_config.yml中添加123456789101112131415neat_enable: trueneat_html: enable: ture exclude:neat_css: enable: true exclude: - '*.min.css'neat_js: enable: true mangle: true output: compress: exclude: - '*.min.js'15: 单击页面出现小爱心找到主题下面 layout.ejs 文件夹： themes\hexo-theme-pure\layout\layout.ejs 最下面添加以下代码1&lt;script type="text/javascript" src="//cdn.jsdelivr.net/gh/ygbhf/clicklove/clicklove.js"&gt;&lt;/script&gt;16: 取消目录的编号修改：hexo\themes\hexo-theme-pure\layout_partial\sidebar-toc.ejs 文件夹下的123&lt;%- toc(post.content) %&gt;改为&lt;%- toc(post.content,&#123;list_number: false&#125;) %&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用（一） 搭建博客]]></title>
    <url>%2F2017%2F05%2F27%2Fhexo%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1: 先要在本地安装 node 和 git 环境，申请域名。2: npm 全局安装 hexo1npm install -g hexo3: 创建一个空目录：如我是 hexo, 再初始化 hexo1hexo init4: 预览上传博客12hexo server --debug// 打开 localhost:4000 访问预览如果有恭喜你成功了。5: 上传到github5.1: 在站点配置文件_config.yml中添加以下代码，仓库地址改为你的github仓库地址，用来连接你自己的 github 地址1234deploy: type: git repository: git@github.com:xiechunhao/xiechunhao.github.io.git branch: master5.1: 提交1234hexo generate // 或者简写 hexo ghexo deploy // 或者简写 hexo dhexo clean // 清空缓存// 设置 github 博客项目的 setting 的 GitHub Pages 的 Custom domain 为自己的域名即可6: github 创建一个博客的仓库，配置gitPage6.1: 申请一个自己的域名，阿里云可以去申请（把 xiechunhao.github.io 博客地址映射到 域名上）6.2: 打开仓库的 setting 配置 GitHub Pages 的 Custom domain 域名为你自己申请的域名, 如我的是：然后 通过域名就可以访问到你自己的博客网站了，但是样式比较丑，我们可以去下载好看的主题并配置即可。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
