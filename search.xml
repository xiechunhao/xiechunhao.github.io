<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[快递单号接口开发API]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%BF%AB%E9%80%92%E5%8D%95%E5%8F%B7%E6%8E%A5%E5%8F%A3API%2F</url>
    <content type="text"><![CDATA[1: 应用场景：物流信息查询 2: 本接口采用的是聚合数据接口：https://www.juhe.cn/docs/api/id/433: 注册账号申请快递单号接口：获取申请的key 4: 接口参数查看（主要是这三个需要传到服务端） 5: 实现代码12345678910111213141516171819&lt;!-- Jquery保证在1.12及以上 --&gt;&lt;script src="./jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;script&gt; var $key = "870967b6f718e99ceda764f1829c1763"; //申请的商户ID var $kdNumber = "3383748328872"; //快递单号 var $com = "sto"; //快递物流公司简称 如：STO申通 SF顺风等 $.get(&#123; url:'http://v.juhe.cn/exp/index', data:&#123; key : $key, com : $com, no : $kdNumber &#125;, dataType:"jsonp", success:function(data)&#123; console.log(data); &#125; &#125;);&lt;/script&gt; 使用JQuery的Ajax访问（经测试直接访问获取不到数据，因为服务端没有主动设置开放CROS资源共享）浏览器会默认同源策略，所以访问失败。需要设 dataType = “jsonp” 跨域访问。 返回成果的物流信息 6: 查看聚合数据支持的哪些快递公司的查询：https://www.juhe.cn/box/index/id/43]]></content>
      <categories>
        <category>第三方接口</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 递归的深入理解]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%80%92%E5%BD%92%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1: 递归 : 在函数内调用函数自己 自己调用自己 结束的条件 了解 函数在调用的时候才会占用内存, 不调用不会占内存 没有递归结束条件的递归就是死递归 会出现堆溢出. 2: 递归的优缺点:优点 代码简洁 在树的前序，中序，后序遍历算法中，递归的实现明显要比循环简单得多。 缺点 递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。-&gt;效率 递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分，则存在重复计算，如fibonacci斐波那契数列的递归实现。-&gt; 效率 调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。-&gt;性能 3: 实例: 递归实现累计求和: 12345678function getSum(n) &#123; if(n == 1)&#123; return 1; &#125;else&#123; return n + getSum(n-1); &#125; &#125;console.log(getSum(10)); //55 递归实现阶乘: 12345678function getChen(n) &#123; if(n == 1)&#123; return 1; &#125;else&#123; return n * getChen(n-1); &#125;&#125;console.log(getChen(5)); //120 5*4*3*2*1 斐波那契求第N位数的值:出现重复计算: 内存消耗 12345678 function feiBo(n) &#123; if(n == 1 || n == 2)&#123; return 1; &#125;else &#123; return feiBo(n-2) + feiBo(n-1); &#125; &#125;console.log(feiBo(10)); 递归常用在遍历DOM树下面的所有元素 12345678910111213141516//需求：获取id为father元素的所有后代元素//dom中有没有直接的api可以获取呢？ 没有，只能自己封装函数实现/*思路1.写一个函数，遍历这个元素的childred子元素，获取它的子元素2.让它的每一个子元素继续调用这个函数，遍历子元素的子元素，形成递归调用 */var father = document.getElementById('father');var list = [];function houDai(ele) &#123; for (var i = 0; i &lt; ele.children.length; i++) &#123; list.push(ele.children[i]); houDai(ele.children[i]); &#125;&#125;houDai(father);console.log(list); 面试题阶乘，求res值? 1var res = (function (n) &#123;return n == 1 ? 1 : n * arguments.callee(n-1)&#125;)(5); 解析: 就是递归阶乘. arguments.callee()是获取匿名函数的函数名.因为是匿名函数只能通过这样才能获取实现递归]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 闭包的深入理解]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%97%AD%E5%8C%85%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1: JS中什么是闭包 ？就是函数 （闭包是一个可以获取其他函数内部变量的函数） 2: 闭包作用 延长生命周期 在函数外部要想访问或者修改数据,只能通过函数的内部的方法 设置安全措施,校验之内的操作,可以保证系统的安全性和稳定性 3: 闭包语法 函数内部声明一个闭包函数 在闭包函数中返回想要访问的局部变量 返回闭包函数 4: 闭包本质：函数内部与函数外部连接起来的一座桥梁5: 闭包的原理上级作用域无法访问下级的作用域 6: 闭包要解决的问题 闭包内的数据不允许外界访问 要解决的问题就是间接的访问该数据 7: 闭包的实际应用场景12345678910111213141516171819202122/*闭包实际开发应用场景 -----沙箱模式 ： 一种独立的内存空间，通常是匿名函数自调用 a.提供不同的作用域---避免全局变量污染 b.模块化开发----不同的功能对应不同的作用域 */(function ( w ) &#123; var p = &#123; name:&apos;张三&apos;, sayHi:function ( ) &#123; console.log ( &quot;今天学到好多东西&quot; ); &#125; &#125;; var num = 10; //沙箱模式中所有的变量都是局部的，如何可以在外部全局变量中访问？ //将需要暴露外部的api作为window的属性 /*这里为什么不直接使用window而使用形参来接收呢？ 1.沙箱内部不能直接访问外部变量，会破坏封装性 2.以后的开发中为了减少js文件的大小，会使用专业的压缩工具来压缩,为了避免压缩工具压缩代码导致错误， 通常不直接使用window */ w.p = p;&#125;)(window);console.log ( p );//window.person 8: 简单的闭包实例 获取或者修改数据 获取多个数据和修改多个数据 9: 闭包经典面试题 求 this 的指向 1234567891011121314// 返回: Window Name，调用person.getName() 返回值是一个匿名函数，此时在全局作用域中调用匿名函数，此时this指向windowvar name = 'Window Name';var person = &#123; name:'Object Name', getName:function ( ) &#123; return function ( ) &#123; return this.name; &#125; &#125;&#125;;// var fn = person.getName();// fn();console.log ( person.getName () () );//Window Name 12345678910111213// 调用person.getName(),在getName方法中this指向person。此时用一个句变量that存储this（person），返回一个匿名函数，函数中that指向personvar name = 'Window Name';var person = &#123; name:'Object Name', getName:function ( ) &#123; var that = this; return function ( ) &#123; return that.name; &#125; &#125;&#125;;console.log ( person.getName () () );//Object Name 使用闭包来计算数组递归:(高性能) 12345678910111213function feiBo() &#123; var arr = [1,1,0]; function closoure(n) &#123; for (var i = 2; i &lt; n; i++) &#123; arr[2] = arr[0] + arr[1]; arr[0] = arr[1]; arr[1] = arr[2]; &#125; return arr[2]; &#125; return closoure;&#125;console.log(feiBo()(10));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm 介绍及常用命令]]></title>
    <url>%2F2019%2F02%2F28%2Fnpm%20%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[npm 介绍及常用命令npm 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径，只要电脑安装了 node 就 安装了 npm 包管理工具 1. npm 官网地址1https://www.npmjs.com/ 2.npm常用命令123456789npm install --global npm // 自己升级自己npm init // 项目初始化npm init -y // 可以直接跳过向导，快速生成npm install // 一次性把dependencies选项中的依赖项全部安装npm install 包名 //下载包名npm install --save 包名 //下载并保存依赖项，（package.json文件中的dependenice选项）npm uninstall 包名 //只删除，如果有依赖选会依然保存npm uninstall --save 包名 //删除的同时会把依赖的信息也去除npm help //查看使用帮助 3.安装慢或者被墙问题解决办法npm存储包文件的服务器在国外，有时候会被墙，速度很慢，所以我们需要解决这个问题 http://npm.taobao.org/：淘宝的开发团队吧npm在国内做了一个备份，每10分钟会被备份一次 所以我们安装淘宝的cnpm 1npm install --global npm 接下来你安装包的时候把之前的npm替换成cnpm既可：举列如下 12345//这个是走国外的服务器，速度比较慢npm install jquery//使用cnpm 就是走淘宝服务器，速度比较快。cnpm install jquery 如果不想安装cnpm又想使用淘宝的服务器来下载： 123npm config set registry=https://registry.npm.taobao.org//查看npm配置文件npm config list]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
</search>
