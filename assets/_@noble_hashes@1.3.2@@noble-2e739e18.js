function A(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("Wrong positive integer: ".concat(e))}function U(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error("Expected Uint8Array of length ".concat(t,", not of length=").concat(e.length))}function j(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");A(e.outputLen),A(e.blockLen)}function g(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function S(e,t){U(e);const s=t.outputLen;if(e.length<s)throw new Error("digestInto() expects output buffer of length at least ".concat(s))}const k=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C=e=>e instanceof Uint8Array,G=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),I=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),d=(e,t)=>e<<32-t|e>>>t,R=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!R)throw new Error("Non little-endian hardware is not supported");function X(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got ".concat(typeof e));return new Uint8Array(new TextEncoder().encode(e))}function H(e){if(typeof e=="string"&&(e=X(e)),!C(e))throw new Error("expected Uint8Array, got ".concat(typeof e));return e}function ut(...e){const t=new Uint8Array(e.reduce((i,o)=>i+o.length,0));let s=0;return e.forEach(i=>{if(!C(i))throw new Error("Uint8Array expected");t.set(i,s),s+=i.length}),t}class B{clone(){return this._cloneInto()}}function F(e){const t=i=>e().update(H(i)).digest(),s=e();return t.outputLen=s.outputLen,t.blockLen=s.blockLen,t.create=()=>e(),t}function lt(e=32){if(k&&typeof k.getRandomValues=="function")return k.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}class N extends B{constructor(t,s){super(),this.finished=!1,this.destroyed=!1,j(t);const i=H(s);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,r=new Uint8Array(o);r.set(i.length>o?t.create().update(i).digest():i);for(let n=0;n<r.length;n++)r[n]^=54;this.iHash.update(r),this.oHash=t.create();for(let n=0;n<r.length;n++)r[n]^=106;this.oHash.update(r),r.fill(0)}update(t){return g(this),this.iHash.update(t),this}digestInto(t){g(this),U(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:s,iHash:i,finished:o,destroyed:r,blockLen:n,outputLen:h}=this;return t=t,t.finished=o,t.destroyed=r,t.blockLen=n,t.outputLen=h,t.oHash=s._cloneInto(t.oHash),t.iHash=i._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const P=(e,t,s)=>new N(e,t).update(s).digest();P.create=(e,t)=>new N(e,t);function W(e,t,s,i){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,s,i);const o=BigInt(32),r=BigInt(4294967295),n=Number(s>>o&r),h=Number(s&r),f=i?4:0,a=i?0:4;e.setUint32(t+f,n,i),e.setUint32(t+a,h,i)}class $ extends B{constructor(t,s,i,o){super(),this.blockLen=t,this.outputLen=s,this.padOffset=i,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=I(this.buffer)}update(t){g(this);const{view:s,buffer:i,blockLen:o}=this;t=H(t);const r=t.length;for(let n=0;n<r;){const h=Math.min(o-this.pos,r-n);if(h===o){const f=I(t);for(;o<=r-n;n+=o)this.process(f,n);continue}i.set(t.subarray(n,n+h),this.pos),this.pos+=h,n+=h,this.pos===o&&(this.process(s,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){g(this),S(t,this),this.finished=!0;const{buffer:s,view:i,blockLen:o,isLE:r}=this;let{pos:n}=this;s[n++]=128,this.buffer.subarray(n).fill(0),this.padOffset>o-n&&(this.process(i,0),n=0);for(let c=n;c<o;c++)s[c]=0;W(i,o-8,BigInt(this.length*8),r),this.process(i,0);const h=I(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=f/4,u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let c=0;c<a;c++)h.setUint32(4*c,u[c],r)}digest(){const{buffer:t,outputLen:s}=this;this.digestInto(t);const i=t.slice(0,s);return this.destroy(),i}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:s,buffer:i,length:o,finished:r,destroyed:n,pos:h}=this;return t.length=o,t.pos=h,t.finished=r,t.destroyed=n,o%s&&t.buffer.set(i),t}}const K=(e,t,s)=>e&t^~e&s,q=(e,t,s)=>e&t^e&s^t&s,v=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),x=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),p=new Uint32Array(64);class z extends ${constructor(){super(64,32,8,!1),this.A=x[0]|0,this.B=x[1]|0,this.C=x[2]|0,this.D=x[3]|0,this.E=x[4]|0,this.F=x[5]|0,this.G=x[6]|0,this.H=x[7]|0}get(){const{A:t,B:s,C:i,D:o,E:r,F:n,G:h,H:f}=this;return[t,s,i,o,r,n,h,f]}set(t,s,i,o,r,n,h,f){this.A=t|0,this.B=s|0,this.C=i|0,this.D=o|0,this.E=r|0,this.F=n|0,this.G=h|0,this.H=f|0}process(t,s){for(let c=0;c<16;c++,s+=4)p[c]=t.getUint32(s,!1);for(let c=16;c<64;c++){const b=p[c-15],l=p[c-2],E=d(b,7)^d(b,18)^b>>>3,L=d(l,17)^d(l,19)^l>>>10;p[c]=L+p[c-7]+E+p[c-16]|0}let{A:i,B:o,C:r,D:n,E:h,F:f,G:a,H:u}=this;for(let c=0;c<64;c++){const b=d(h,6)^d(h,11)^d(h,25),l=u+b+K(h,f,a)+v[c]+p[c]|0,L=(d(i,2)^d(i,13)^d(i,22))+q(i,o,r)|0;u=a,a=f,f=h,h=n+l|0,n=r,r=o,o=i,i=l+L|0}i=i+this.A|0,o=o+this.B|0,r=r+this.C|0,n=n+this.D|0,h=h+this.E|0,f=f+this.F|0,a=a+this.G|0,u=u+this.H|0,this.set(i,o,r,n,h,f,a,u)}roundClean(){p.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const dt=F(()=>new z),w=BigInt(2**32-1),m=BigInt(32);function J(e,t=!1){return t?{h:Number(e&w),l:Number(e>>m&w)}:{h:Number(e>>m&w)|0,l:Number(e&w)|0}}function Q(e,t=!1){let s=new Uint32Array(e.length),i=new Uint32Array(e.length);for(let o=0;o<e.length;o++){const{h:r,l:n}=J(e[o],t);[s[o],i[o]]=[r,n]}return[s,i]}const Y=(e,t,s)=>e<<s|t>>>32-s,Z=(e,t,s)=>t<<s|e>>>32-s,tt=(e,t,s)=>t<<s-32|e>>>64-s,et=(e,t,s)=>e<<s-32|t>>>64-s,[M,V,D]=[[],[],[]],st=BigInt(0),y=BigInt(1),nt=BigInt(2),it=BigInt(7),ot=BigInt(256),rt=BigInt(113);for(let e=0,t=y,s=1,i=0;e<24;e++){[s,i]=[i,(2*s+3*i)%5],M.push(2*(5*i+s)),V.push((e+1)*(e+2)/2%64);let o=st;for(let r=0;r<7;r++)t=(t<<y^(t>>it)*rt)%ot,t&nt&&(o^=y<<(y<<BigInt(r))-y);D.push(o)}const[ht,ct]=Q(D,!0),O=(e,t,s)=>s>32?tt(e,t,s):Y(e,t,s),T=(e,t,s)=>s>32?et(e,t,s):Z(e,t,s);function ft(e,t=24){const s=new Uint32Array(10);for(let i=24-t;i<24;i++){for(let n=0;n<10;n++)s[n]=e[n]^e[n+10]^e[n+20]^e[n+30]^e[n+40];for(let n=0;n<10;n+=2){const h=(n+8)%10,f=(n+2)%10,a=s[f],u=s[f+1],c=O(a,u,1)^s[h],b=T(a,u,1)^s[h+1];for(let l=0;l<50;l+=10)e[n+l]^=c,e[n+l+1]^=b}let o=e[2],r=e[3];for(let n=0;n<24;n++){const h=V[n],f=O(o,r,h),a=T(o,r,h),u=M[n];o=e[u],r=e[u+1],e[u]=f,e[u+1]=a}for(let n=0;n<50;n+=10){for(let h=0;h<10;h++)s[h]=e[n+h];for(let h=0;h<10;h++)e[n+h]^=~s[(h+2)%10]&s[(h+4)%10]}e[0]^=ht[i],e[1]^=ct[i]}s.fill(0)}class _ extends B{constructor(t,s,i,o=!1,r=24){if(super(),this.blockLen=t,this.suffix=s,this.outputLen=i,this.enableXOF=o,this.rounds=r,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,A(i),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=G(this.state)}keccak(){ft(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){g(this);const{blockLen:s,state:i}=this;t=H(t);const o=t.length;for(let r=0;r<o;){const n=Math.min(s-this.pos,o-r);for(let h=0;h<n;h++)i[this.pos++]^=t[r++];this.pos===s&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:s,pos:i,blockLen:o}=this;t[i]^=s,s&128&&i===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){g(this,!1),U(t),this.finish();const s=this.state,{blockLen:i}=this;for(let o=0,r=t.length;o<r;){this.posOut>=i&&this.keccak();const n=Math.min(i-this.posOut,r-o);t.set(s.subarray(this.posOut,this.posOut+n),o),this.posOut+=n,o+=n}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return A(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(S(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:s,suffix:i,outputLen:o,rounds:r,enableXOF:n}=this;return t||(t=new _(s,i,o,n,r)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=r,t.suffix=i,t.outputLen=o,t.enableXOF=n,t.destroyed=this.destroyed,t}}const at=(e,t,s)=>F(()=>new _(t,e,s)),xt=at(1,136,256/8);export{ut as c,P as h,xt as k,lt as r,dt as s};
