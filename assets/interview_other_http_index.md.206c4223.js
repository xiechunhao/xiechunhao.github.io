import{_ as e,o as l,c as i,O as o}from"./chunks/framework.57763b9a.js";const b=JSON.parse('{"title":"http服务器和网络面试题","description":"","frontmatter":{},"headers":[],"relativePath":"interview/other/http/index.md","filePath":"interview/other/http/index.md","lastUpdated":1688111209000}'),t={name:"interview/other/http/index.md"},c=o(`<h1 id="http服务器和网络面试题" tabindex="-1">http服务器和网络面试题 <a class="header-anchor" href="#http服务器和网络面试题" aria-label="Permalink to &quot;http服务器和网络面试题&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>总结的一些http服务器和网络面试题目</p></div><h2 id="_1-http-https协议" tabindex="-1">1.http/https协议 <a class="header-anchor" href="#_1-http-https协议" aria-label="Permalink to &quot;1.http/https协议&quot;">​</a></h2><ol><li><code>http</code> 超文本传输协议，是基于请求与响应，无状态的，应用层的协议。基于TCP/IP协议传输数据。多路复用：通过单一的HTTP链接请求发起多重的请求-响应消息，多个stream共享一个TCP连接，实现多留并行而不依赖建立多个TCP连接</li><li><code>https</code> 基于http协议，经由http进行通信，利用SSL/TLS建立安全通信，加密数据包，https使用主要目的是提供对服务网站的身份认证，同时保证交换数据的隐私和完整性</li><li>http vs https <ul><li><strong>http 特点：</strong></li><li><pre><code>   a.无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行
     登录操作
</code></pre></li><li><pre><code>   b.无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新
     建立连接。
     比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以
     每次需要重新响应请求，
     需要耗费不必要的时间和流量。
</code></pre></li><li><pre><code>   c.基于请求和响应：基本的特性，由客户端发起请求，服务端响应
</code></pre></li><li><pre><code>   d.简单快速、灵活
</code></pre></li><li><pre><code>   e.通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性
</code></pre></li><li><strong>https 特点：</strong></li><li><pre><code>   a.基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护
</code></pre></li><li><pre><code>   b.通过抓包可以看到数据不是明文传输，而且HTTPS有如下特点：
</code></pre></li><li><pre><code>       -  内容加密：采用混合加密技术，中间者无法直接查看明文内容
</code></pre></li><li><pre><code>       -  验证身份：通过证书认证客户端访问的是自己的服务器
</code></pre></li><li><pre><code>       -  保护数据完整性：防止传输的内容被中间人冒充或者篡改
</code></pre></li></ul></li></ol><h2 id="_2-tcp三次握手-四次挥手" tabindex="-1">2.TCP三次握手，四次挥手 <a class="header-anchor" href="#_2-tcp三次握手-四次挥手" aria-label="Permalink to &quot;2.TCP三次握手，四次挥手&quot;">​</a></h2><ol><li><p>为什么要三次握手？</p><ul><li>为了防止已经失效的连接请求报文段突然又传输到服务端，因而产生的错误 比如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。</li></ul></li><li><p>为什么需要四次挥手呢？</p><ul><li>TCP是全双工模式，当client发出FIN报文段时，只是表示client已经没有数据要发送了，client告诉server，它的数据已经全部发送完毕了；但是，这个时候client还是可以接受来server的数据；当server返回ACK报文段时，表示它已经知道client没有数据发送了，但是server还是可以发送数据到client的；当server也发送了FIN报文段时，这个时候就表示server也没有数据要发送了，就会告诉client，我也没有数据要发送了，如果收到client确认报文段，之后彼此就会愉快的中断这次TCP连接。</li></ul></li></ol><h2 id="_3-get-post区别" tabindex="-1">3.get / post区别 <a class="header-anchor" href="#_3-get-post区别" aria-label="Permalink to &quot;3.get / post区别&quot;">​</a></h2><ol><li><code>get</code> 缓存，请求长度受限制，会被历史保持记录，不安全url可见</li><li><code>post</code> 安全不可见，大数据，更多编码类型</li></ol><h2 id="_4-websocket" tabindex="-1">4.Websocket <a class="header-anchor" href="#_4-websocket" aria-label="Permalink to &quot;4.Websocket&quot;">​</a></h2><ol><li>客户端和服务端的即时通讯，服务端不断发送push数据</li></ol><h2 id="_5-为什么存在跨域" tabindex="-1">5.为什么存在跨域 <a class="header-anchor" href="#_5-为什么存在跨域" aria-label="Permalink to &quot;5.为什么存在跨域&quot;">​</a></h2><ol><li>浏览器的安全同源策略，所谓协议，域名，端口三者必须相同。否则存在跨域</li><li>html中，img标签，link标签，和script标签允许跨域</li></ol><h2 id="_6-怎么解决跨域有哪些方法-原理是什么" tabindex="-1">6.怎么解决跨域有哪些方法，原理是什么 <a class="header-anchor" href="#_6-怎么解决跨域有哪些方法-原理是什么" aria-label="Permalink to &quot;6.怎么解决跨域有哪些方法，原理是什么&quot;">​</a></h2><ol><li><code>jsonp</code> 利用<code>&lt;script&gt;</code>标签没有跨域限制的漏洞，网站可以得到其动态的产生JSONP数据，JSONP请求一定需要服务端做支持才可以，只支持get请求</li><li><code>cros</code> 浏览器会自动进行CORS通讯，实现CORS通讯关键是后端，只要后端头部设置CORS就实现了跨域</li><li><code>node中间件</code> 同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</li><li><code>nginx</code> 反向代理，需要搭建一个nginx服务器，用于转发请求，只需要修改nginx配置即可解决跨域问题，不需要修改任何代码，并且不会影响服务器性能（跟node中间件原理一致）</li><li><code>jquery</code> 发生ajax请求 设置 type为jsonp</li><li>vue 配置 <code>proxy</code> 开发代理跨域</li><li><code>window.name + iframe</code> window.name 独特之处在于，name值在不同页面（甚至不同域名）加载后依旧存在，并且支持值长的name值（2MB)</li><li>工作中常用的是CROS和nginx</li></ol><h2 id="_7-怎么防止安全" tabindex="-1">7.怎么防止安全 <a class="header-anchor" href="#_7-怎么防止安全" aria-label="Permalink to &quot;7.怎么防止安全&quot;">​</a></h2><ol><li><code>XSS攻击</code> 注入恶意代码（不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等））</li><li><code>cookie设置HttpOnly</code><ul><li>转义页面上输入内容和输出内容</li></ul></li><li><code>CSRF</code> 跨站点请求伪造，防护： <ul><li>token 验证</li><li>授信令牌</li><li>get 不修改数据</li><li>Referer 请求校验（对请求来源进行验证）</li><li>不被第三方网站访问到cookie</li><li>设置白名单，不被第三方网站请求</li></ul></li><li>防止：<code>SQL注入攻击</code></li><li>数据加密（<code>MD5</code>，<code>国密</code>等）</li></ol><h2 id="_8-xss和csrf区别" tabindex="-1">8.XSS和CSRF区别 <a class="header-anchor" href="#_8-xss和csrf区别" aria-label="Permalink to &quot;8.XSS和CSRF区别&quot;">​</a></h2><ol><li><code>CSRF</code> 需要用户先登录网站A，获取 cookie。XSS：不需要登录。</li><li><code>CSRF</code> 是利用网站A本身的漏洞，去请求网站A的api。XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</li></ol><h2 id="_9-http常见状态码" tabindex="-1">9.http常见状态码 <a class="header-anchor" href="#_9-http常见状态码" aria-label="Permalink to &quot;9.http常见状态码&quot;">​</a></h2><ol><li><code>1xx</code> 接受，继续处理</li><li><code>200</code> 成功，并返回数据</li><li><code>201</code> 已创建</li><li><code>202</code> 已接受</li><li><code>203</code> 成为，但未授权</li><li><code>204</code> 成功，无内容</li><li><code>205</code> 成功，重置内容</li><li><code>206</code> 成功，部分内容</li><li><code>301</code> 永久移动，重定向</li><li><code>302</code> 临时移动，可使用原有URI</li><li><code>304</code> 资源未修改，可使用缓存</li><li><code>305</code> 需代理访问</li><li><code>400</code> 请求语法错误</li><li><code>401</code> 要求身份认证</li><li><code>403</code> 拒绝请求</li><li><code>404</code> 资源不存在</li><li><code>500</code> 服务器错误</li></ol><h2 id="更多面试题-参考文档" tabindex="-1">更多面试题，参考文档: <a class="header-anchor" href="#更多面试题-参考文档" aria-label="Permalink to &quot;更多面试题，参考文档:&quot;">​</a></h2><p><a href="https://zhuanlan.zhihu.com/p/72616216" target="_blank" rel="noreferrer">十分钟搞懂HTTP和HTTPS协议？</a> <br><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617" target="_blank" rel="noreferrer">HTTP和HTTPS协议，看一篇就够了</a> <br><a href="https://www.cnblogs.com/fundebug/p/10329202.html" target="_blank" rel="noreferrer">一行代码搞定BUG监控</a></p>`,22),r=[c];function a(d,n,h,s,p,u){return l(),i("div",null,r)}const S=e(t,[["render",a]]);export{b as __pageData,S as default};
