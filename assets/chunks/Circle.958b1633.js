import{c7 as c,bu as f,ax as C,c8 as u,c9 as g,bN as p}from"./reproj.50e0d4ab.js";class l extends c{constructor(t,s,e){super(),e!==void 0&&s===void 0?this.setFlatCoordinates(e,t):(s=s||0,this.setCenterAndRadius(t,s,e))}clone(){const t=new l(this.flatCoordinates.slice(),void 0,this.layout);return t.applyProperties(this),t}closestPointXY(t,s,e,i){const r=this.flatCoordinates,o=t-r[0],a=s-r[1],d=o*o+a*a;if(d<i){if(d===0)for(let n=0;n<this.stride;++n)e[n]=r[n];else{const n=this.getRadius()/Math.sqrt(d);e[0]=r[0]+n*o,e[1]=r[1]+n*a;for(let h=2;h<this.stride;++h)e[h]=r[h]}return e.length=this.stride,d}return i}containsXY(t,s){const e=this.flatCoordinates,i=t-e[0],r=s-e[1];return i*i+r*r<=this.getRadiusSquared_()}getCenter(){return this.flatCoordinates.slice(0,this.stride)}computeExtent(t){const s=this.flatCoordinates,e=s[this.stride]-s[0];return f(s[0]-e,s[1]-e,s[0]+e,s[1]+e,t)}getRadius(){return Math.sqrt(this.getRadiusSquared_())}getRadiusSquared_(){const t=this.flatCoordinates[this.stride]-this.flatCoordinates[0],s=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return t*t+s*s}getType(){return"Circle"}intersectsExtent(t){const s=this.getExtent();if(C(t,s)){const e=this.getCenter();return t[0]<=e[0]&&t[2]>=e[0]||t[1]<=e[1]&&t[3]>=e[1]?!0:u(t,this.intersectsCoordinate.bind(this))}return!1}setCenter(t){const s=this.stride,e=this.flatCoordinates[s]-this.flatCoordinates[0],i=t.slice();i[s]=i[0]+e;for(let r=1;r<s;++r)i[s+r]=t[r];this.setFlatCoordinates(this.layout,i),this.changed()}setCenterAndRadius(t,s,e){this.setLayout(e,t,0),this.flatCoordinates||(this.flatCoordinates=[]);const i=this.flatCoordinates;let r=g(i,0,t,this.stride);i[r++]=i[0]+s;for(let o=1,a=this.stride;o<a;++o)i[r++]=i[o];i.length=r,this.changed()}getCoordinates(){return null}setCoordinates(t,s){}setRadius(t){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+t,this.changed()}rotate(t,s){const e=this.getCenter(),i=this.getStride();this.setCenter(p(e,0,e.length,i,t,s,e)),this.changed()}}l.prototype.transform;const R=l;export{R as C};
