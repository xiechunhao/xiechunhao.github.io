import{c7 as v,A as C,ca as _,W as A,bh as F,g as p,cb as M,cc as x,cd as I,aP as w,ce as X,cf as Y,cg as O,ch as T,ci as G,bA as j,cj as L,ck as $,cl as K,P,cm as b,cn as z,co as U,aD as k,_ as B,E as D,cp as H,cq as N,az as W}from"./reproj.50e0d4ab.js";class y extends v{constructor(t,e){super(),e&&!Array.isArray(t[0])?this.setFlatCoordinates(e,t):this.setCoordinates(t,e)}appendPoint(t){this.flatCoordinates?C(this.flatCoordinates,t.getFlatCoordinates()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.changed()}clone(){const t=new y(this.flatCoordinates.slice(),this.layout);return t.applyProperties(this),t}closestPointXY(t,e,s,i){if(i<_(this.getExtent(),t,e))return i;const n=this.flatCoordinates,o=this.stride;for(let r=0,l=n.length;r<l;r+=o){const h=A(t,e,n[r],n[r+1]);if(h<i){i=h;for(let a=0;a<o;++a)s[a]=n[r+a];s.length=o}}return i}getCoordinates(){return F(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)}getPoint(t){const e=this.flatCoordinates?this.flatCoordinates.length/this.stride:0;return t<0||e<=t?null:new p(this.flatCoordinates.slice(t*this.stride,(t+1)*this.stride),this.layout)}getPoints(){const t=this.flatCoordinates,e=this.layout,s=this.stride,i=[];for(let n=0,o=t.length;n<o;n+=s){const r=new p(t.slice(n,n+s),e);i.push(r)}return i}getType(){return"MultiPoint"}intersectsExtent(t){const e=this.flatCoordinates,s=this.stride;for(let i=0,n=e.length;i<n;i+=s){const o=e[i],r=e[i+1];if(M(t,o,r))return!0}return!1}setCoordinates(t,e){this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=x(this.flatCoordinates,0,t,this.stride),this.changed()}}const J=y;function Q(f,t,e,s){const i=[];let n=w();for(let o=0,r=e.length;o<r;++o){const l=e[o];n=I(f,t,l[0],s),i.push((n[0]+n[2])/2,(n[1]+n[3])/2),t=l[l.length-1]}return i}class c extends v{constructor(t,e,s){if(super(),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!s&&!Array.isArray(t[0])){let i=this.getLayout();const n=t,o=[],r=[];for(let l=0,h=n.length;l<h;++l){const a=n[l];l===0&&(i=a.getLayout());const d=o.length,g=a.getEnds();for(let m=0,R=g.length;m<R;++m)g[m]+=d;C(o,a.getFlatCoordinates()),r.push(g)}e=i,t=o,s=r}e!==void 0&&s?(this.setFlatCoordinates(e,t),this.endss_=s):this.setCoordinates(t,e)}appendPolygon(t){let e;if(!this.flatCoordinates)this.flatCoordinates=t.getFlatCoordinates().slice(),e=t.getEnds().slice(),this.endss_.push();else{const s=this.flatCoordinates.length;C(this.flatCoordinates,t.getFlatCoordinates()),e=t.getEnds().slice();for(let i=0,n=e.length;i<n;++i)e[i]+=s}this.endss_.push(e),this.changed()}clone(){const t=this.endss_.length,e=new Array(t);for(let i=0;i<t;++i)e[i]=this.endss_[i].slice();const s=new c(this.flatCoordinates.slice(),this.layout,e);return s.applyProperties(this),s}closestPointXY(t,e,s,i){return i<_(this.getExtent(),t,e)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(X(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Y(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,t,e,s,i))}containsXY(t,e){return O(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t,e)}getArea(){return T(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)}getCoordinates(t){let e;return t!==void 0?(e=this.getOrientedFlatCoordinates().slice(),G(e,0,this.endss_,this.stride,t)):e=this.flatCoordinates,j(e,0,this.endss_,this.stride)}getEndss(){return this.endss_}getFlatInteriorPoints(){if(this.flatInteriorPointsRevision_!=this.getRevision()){const t=Q(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=L(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t),this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_}getInteriorPoints(){return new J(this.getFlatInteriorPoints().slice(),"XYM")}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;$(t,0,this.endss_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=G(this.orientedFlatCoordinates_,0,this.endss_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(t){const e=[],s=[];return e.length=K(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(t),e,0,s),new c(e,"XY",s)}getPolygon(t){if(t<0||this.endss_.length<=t)return null;let e;if(t===0)e=0;else{const n=this.endss_[t-1];e=n[n.length-1]}const s=this.endss_[t].slice(),i=s[s.length-1];if(e!==0)for(let n=0,o=s.length;n<o;++n)s[n]-=e;return new P(this.flatCoordinates.slice(e,i),this.layout,s)}getPolygons(){const t=this.layout,e=this.flatCoordinates,s=this.endss_,i=[];let n=0;for(let o=0,r=s.length;o<r;++o){const l=s[o].slice(),h=l[l.length-1];if(n!==0)for(let d=0,g=l.length;d<g;++d)l[d]-=n;const a=new P(e.slice(n,h),t,l);i.push(a),n=h}return i}getType(){return"MultiPolygon"}intersectsExtent(t){return b(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,3),this.flatCoordinates||(this.flatCoordinates=[]);const s=z(this.flatCoordinates,0,t,this.stride,this.endss_);if(s.length===0)this.flatCoordinates.length=0;else{const i=s[s.length-1];this.flatCoordinates.length=i.length===0?0:i[i.length-1]}this.changed()}}const V=c;class u extends U{constructor(t){super(),this.geometries_=t||null,this.changeEventsKeys_=[],this.listenGeometriesChange_()}unlistenGeometriesChange_(){this.changeEventsKeys_.forEach(k),this.changeEventsKeys_.length=0}listenGeometriesChange_(){if(this.geometries_)for(let t=0,e=this.geometries_.length;t<e;++t)this.changeEventsKeys_.push(B(this.geometries_[t],D.CHANGE,this.changed,this))}clone(){const t=new u(null);return t.setGeometries(this.geometries_),t.applyProperties(this),t}closestPointXY(t,e,s,i){if(i<_(this.getExtent(),t,e))return i;const n=this.geometries_;for(let o=0,r=n.length;o<r;++o)i=n[o].closestPointXY(t,e,s,i);return i}containsXY(t,e){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)if(s[i].containsXY(t,e))return!0;return!1}computeExtent(t){H(t);const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)N(t,e[s].getExtent());return t}getGeometries(){return E(this.geometries_)}getGeometriesArray(){return this.geometries_}getGeometriesArrayRecursive(){let t=[];const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)e[s].getType()===this.getType()?t=t.concat(e[s].getGeometriesArrayRecursive()):t.push(e[s]);return t}getSimplifiedGeometry(t){if(this.simplifiedGeometryRevision!==this.getRevision()&&(this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),t<0||this.simplifiedGeometryMaxMinSquaredTolerance!==0&&t<this.simplifiedGeometryMaxMinSquaredTolerance)return this;const e=[],s=this.geometries_;let i=!1;for(let n=0,o=s.length;n<o;++n){const r=s[n],l=r.getSimplifiedGeometry(t);e.push(l),l!==r&&(i=!0)}if(i){const n=new u(null);return n.setGeometriesArray(e),n}return this.simplifiedGeometryMaxMinSquaredTolerance=t,this}getType(){return"GeometryCollection"}intersectsExtent(t){const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)if(e[s].intersectsExtent(t))return!0;return!1}isEmpty(){return this.geometries_.length===0}rotate(t,e){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)s[i].rotate(t,e);this.changed()}scale(t,e,s){s||(s=W(this.getExtent()));const i=this.geometries_;for(let n=0,o=i.length;n<o;++n)i[n].scale(t,e,s);this.changed()}setGeometries(t){this.setGeometriesArray(E(t))}setGeometriesArray(t){this.unlistenGeometriesChange_(),this.geometries_=t,this.listenGeometriesChange_(),this.changed()}applyTransform(t){const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)e[s].applyTransform(t);this.changed()}translate(t,e){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)s[i].translate(t,e);this.changed()}disposeInternal(){this.unlistenGeometriesChange_(),super.disposeInternal()}}function E(f){const t=[];for(let e=0,s=f.length;e<s;++e)t.push(f[e].clone());return t}const Z=u;export{Z as G,J as M,V as a};
