import{C as O}from"./Circle.958b1633.js";import{a as B,N as X,T as K,j as L,q as N,O as Y,c as G,y as $,Q,E as Z,h as m,R as z,e as J,i as v,g as M,S as R,v as tt,P as A,U as et,W as q,x as it,X as st,Y as nt,Z as ot}from"./reproj.50e0d4ab.js";import{V as rt,c as k,d as at}from"./Vector.f72cf874.js";import{M as ht,a as V,G as ct}from"./GeometryCollection.2da265b8.js";import{L as F}from"./LineString.e8af5305.js";import{M as j}from"./MultiLineString.5776de5d.js";import{V as lt}from"./Vector.0afd591d.js";const w={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};class P extends tt{constructor(t,e){super(t),this.feature=e}}function dt(h,t){const e=[];for(let i=0;i<t.length;++i){const o=t[i].getGeometry();U(h,o,e)}return e}function T(h,t){return q(h[0],h[1],t[0],t[1])}function y(h,t){const e=h.length;return t<0?h[t+e]:t>=e?h[t-e]:h[t]}function x(h,t,e){let i,s;t<e?(i=t,s=e):(i=e,s=t);const o=Math.ceil(i),n=Math.floor(s);if(o>n){const a=C(h,i),c=C(h,s);return T(a,c)}let r=0;if(i<o){const a=C(h,i),c=y(h,o);r+=T(a,c)}if(n<s){const a=y(h,n),c=C(h,s);r+=T(a,c)}for(let a=o;a<n-1;++a){const c=y(h,a),d=y(h,a+1);r+=T(c,d)}return r}function U(h,t,e){if(t instanceof F){D(h,t.getCoordinates(),!1,e);return}if(t instanceof j){const i=t.getCoordinates();for(let s=0,o=i.length;s<o;++s)D(h,i[s],!1,e);return}if(t instanceof A){const i=t.getCoordinates();for(let s=0,o=i.length;s<o;++s)D(h,i[s],!0,e);return}if(t instanceof V){const i=t.getCoordinates();for(let s=0,o=i.length;s<o;++s){const n=i[s];for(let r=0,a=n.length;r<a;++r)D(h,n[r],!0,e)}return}if(t instanceof ct){const i=t.getGeometries();for(let s=0;s<i.length;++s)U(h,i[s],e);return}}const I={index:-1,endIndex:NaN};function _t(h,t,e,i){const s=h[0],o=h[1];let n=1/0,r=-1,a=NaN;for(let l=0;l<t.targets.length;++l){const _=t.targets[l],f=_.coordinates;let u=1/0,g;for(let p=0;p<f.length-1;++p){const b=f[p],H=f[p+1],S=W(s,o,b,H);S.squaredDistance<u&&(u=S.squaredDistance,g=p+S.along)}u<n&&(n=u,_.ring&&t.targetIndex===l&&(_.endIndex>_.startIndex?g<_.startIndex&&(g+=f.length):_.endIndex<_.startIndex&&g>_.startIndex&&(g-=f.length)),a=g,r=l)}const c=t.targets[r];let d=c.ring;if(t.targetIndex===r&&d){const l=C(c.coordinates,a),_=e.getPixelFromCoordinate(l);v(_,t.startPx)>i&&(d=!1)}if(d){const l=c.coordinates,_=l.length,f=c.startIndex,u=a;if(f<u){const g=x(l,f,u);x(l,f,u-_)<g&&(a-=_)}else{const g=x(l,f,u);x(l,f,u+_)<g&&(a+=_)}}return I.index=r,I.endIndex=a,I}function D(h,t,e,i){const s=h[0],o=h[1];for(let n=0,r=t.length-1;n<r;++n){const a=t[n],c=t[n+1],d=W(s,o,a,c);if(d.squaredDistance===0){const l=n+d.along;i.push({coordinates:t,ring:e,startIndex:l,endIndex:l});return}}}const E={along:0,squaredDistance:0};function W(h,t,e,i){const s=e[0],o=e[1],n=i[0],r=i[1],a=n-s,c=r-o;let d=0,l=s,_=o;return(a!==0||c!==0)&&(d=ot(((h-s)*a+(t-o)*c)/(a*a+c*c),0,1),l+=a*d,_+=c*d),E.along=d,E.squaredDistance=et(q(h,t,l,_),10),E}function C(h,t){const e=h.length;let i=Math.floor(t);const s=t-i;i>=e?i-=e:i<0&&(i+=e);let o=i+1;o>=e&&(o-=e);const n=h[i],r=n[0],a=n[1],c=h[o],d=c[0]-r,l=c[1]-a;return[r+d*s,a+l*s]}class ft extends B{constructor(t){const e=t;e.stopDown||(e.stopDown=X),super(e),this.on,this.once,this.un,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=t.source?t.source:null,this.features_=t.features?t.features:null,this.snapTolerance_=t.snapTolerance?t.snapTolerance:12,this.type_=t.type,this.mode_=gt(this.type_),this.stopClick_=!!t.stopClick,this.minPoints_=t.minPoints?t.minPoints:this.mode_==="Polygon"?3:2,this.maxPoints_=this.mode_==="Circle"?2:t.maxPoints?t.maxPoints:1/0,this.finishCondition_=t.finishCondition?t.finishCondition:K,this.geometryLayout_=t.geometryLayout?t.geometryLayout:"XY";let i=t.geometryFunction;if(!i){const s=this.mode_;if(s==="Circle")i=function(o,n,r){const a=n||new O([NaN,NaN]),c=L(o[0]),d=N(c,L(o[o.length-1]));return a.setCenterAndRadius(c,Math.sqrt(d),this.geometryLayout_),a};else{let o;s==="Point"?o=M:s==="LineString"?o=F:s==="Polygon"&&(o=A),i=function(n,r,a){return r?s==="Polygon"?n[0].length?r.setCoordinates([n[0].concat([n[0][0]])],this.geometryLayout_):r.setCoordinates([],this.geometryLayout_):r.setCoordinates(n,this.geometryLayout_):r=new o(n,this.geometryLayout_),r}}}this.geometryFunction_=i,this.dragVertexDelay_=t.dragVertexDelay!==void 0?t.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=t.clickTolerance?t.clickTolerance*t.clickTolerance:36,this.overlay_=new lt({source:new rt({useSpatialIndex:!1,wrapX:t.wrapX?t.wrapX:!1}),style:t.style?t.style:ut(),updateWhileInteracting:!0}),this.geometryName_=t.geometryName,this.condition_=t.condition?t.condition:Y,this.freehandCondition_,t.freehand?this.freehandCondition_=G:this.freehandCondition_=t.freehandCondition?t.freehandCondition:$,this.traceCondition_,this.setTrace(t.trace||!1),this.traceState_={active:!1},this.traceSource_=t.traceSource||t.source||null,this.addChangeListener(Q.ACTIVE,this.updateState_)}setTrace(t){let e;t?t===!0?e=G:e=t:e=it,this.traceCondition_=e}setMap(t){super.setMap(t),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(t){t.originalEvent.type===Z.CONTEXTMENU&&t.originalEvent.preventDefault(),this.freehand_=this.mode_!=="Point"&&this.freehandCondition_(t);let e=t.type===m.POINTERMOVE,i=!0;return!this.freehand_&&this.lastDragTime_&&t.type===m.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=t.pixel,this.shouldHandle_=!this.freehand_,e=!0):this.lastDragTime_=void 0,this.shouldHandle_&&this.downTimeout_!==void 0&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&t.type===m.POINTERDRAG&&this.sketchFeature_!==null?(this.addToDrawing_(t.coordinate),i=!1):this.freehand_&&t.type===m.POINTERDOWN?i=!1:e&&this.getPointerCount()<2?(i=t.type===m.POINTERMOVE,i&&this.freehand_?(this.handlePointerMove_(t),this.shouldHandle_&&t.originalEvent.preventDefault()):(t.originalEvent.pointerType==="mouse"||t.type===m.POINTERDRAG&&this.downTimeout_===void 0)&&this.handlePointerMove_(t)):t.type===m.DBLCLICK&&(i=!1),super.handleEvent(t)&&i}handleDownEvent(t){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=t.pixel,this.finishCoordinate_||this.startDrawing_(t.coordinate),!0):this.condition_(t)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new z(m.POINTERMOVE,t.map,t.originalEvent,!1,t.frameState))},this.dragVertexDelay_),this.downPx_=t.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(t){if(!this.traceSource_||!this.traceCondition_(t))return;if(this.traceState_.active){this.deactivateTrace_();return}const e=this.getMap(),i=e.getCoordinateFromPixel([t.pixel[0]-this.snapTolerance_,t.pixel[1]+this.snapTolerance_]),s=e.getCoordinateFromPixel([t.pixel[0]+this.snapTolerance_,t.pixel[1]-this.snapTolerance_]),o=J([i,s]),n=this.traceSource_.getFeaturesInExtent(o);if(n.length===0)return;const r=dt(t.coordinate,n);r.length&&(this.traceState_={active:!0,startPx:t.pixel.slice(),targets:r,targetIndex:-1})}addOrRemoveTracedCoordinates_(t,e){const i=t.startIndex<=t.endIndex,s=t.startIndex<=e;i===s?i&&e>t.endIndex||!i&&e<t.endIndex?this.addTracedCoordinates_(t,t.endIndex,e):(i&&e<t.endIndex||!i&&e>t.endIndex)&&this.removeTracedCoordinates_(e,t.endIndex):(this.removeTracedCoordinates_(t.startIndex,t.endIndex),this.addTracedCoordinates_(t,t.startIndex,e))}removeTracedCoordinates_(t,e){if(t===e)return;let i=0;if(t<e){const s=Math.ceil(t);let o=Math.floor(e);o===e&&(o-=1),i=o-s+1}else{const s=Math.floor(t);let o=Math.ceil(e);o===e&&(o+=1),i=s-o+1}i>0&&this.removeLastPoints_(i)}addTracedCoordinates_(t,e,i){if(e===i)return;const s=[];if(e<i){const o=Math.ceil(e);let n=Math.floor(i);n===i&&(n-=1);for(let r=o;r<=n;++r)s.push(y(t.coordinates,r))}else{const o=Math.floor(e);let n=Math.ceil(i);n===i&&(n+=1);for(let r=o;r>=n;--r)s.push(y(t.coordinates,r))}s.length&&this.appendCoordinates(s)}updateTrace_(t){const e=this.traceState_;if(!e.active||e.targetIndex===-1&&v(e.startPx,t.pixel)<this.snapTolerance_)return;const i=_t(t.coordinate,e,this.getMap(),this.snapTolerance_);if(e.targetIndex!==i.index){if(e.targetIndex!==-1){const a=e.targets[e.targetIndex];this.removeTracedCoordinates_(a.startIndex,a.endIndex)}const r=e.targets[i.index];this.addTracedCoordinates_(r,r.startIndex,i.endIndex)}else{const r=e.targets[e.targetIndex];this.addOrRemoveTracedCoordinates_(r,i.endIndex)}e.targetIndex=i.index;const s=e.targets[e.targetIndex];s.endIndex=i.endIndex;const o=C(s.coordinates,s.endIndex),n=this.getMap().getPixelFromCoordinate(o);t.coordinate=o,t.pixel=[Math.round(n[0]),Math.round(n[1])]}handleUpEvent(t){let e=!0;if(this.getPointerCount()===0){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(t);const i=this.traceState_.active;if(this.toggleTraceState_(t),this.shouldHandle_){const s=!this.finishCoordinate_;s&&this.startDrawing_(t.coordinate),!s&&this.freehand_?this.finishDrawing():!this.freehand_&&(!s||this.mode_==="Point")&&(this.atFinish_(t.pixel,i)?this.finishCondition_(t)&&this.finishDrawing():this.addToDrawing_(t.coordinate)),e=!1}else this.freehand_&&this.abortDrawing()}return!e&&this.stopClick_&&t.preventDefault(),e}handlePointerMove_(t){if(this.pointerType_=t.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const e=this.downPx_,i=t.pixel,s=e[0]-i[0],o=e[1]-i[1],n=s*s+o*o;if(this.shouldHandle_=this.freehand_?n>this.squaredClickTolerance_:n<=this.squaredClickTolerance_,!this.shouldHandle_)return}if(!this.finishCoordinate_){this.createOrUpdateSketchPoint_(t.coordinate.slice());return}this.updateTrace_(t),this.modifyDrawing_(t.coordinate)}atFinish_(t,e){let i=!1;if(this.sketchFeature_){let s=!1,o=[this.finishCoordinate_];const n=this.mode_;if(n==="Point")i=!0;else if(n==="Circle")i=this.sketchCoords_.length===2;else if(n==="LineString")s=!e&&this.sketchCoords_.length>this.minPoints_;else if(n==="Polygon"){const r=this.sketchCoords_;s=r[0].length>this.minPoints_,o=[r[0][0],r[0][r[0].length-2]],e?o=[r[0][0]]:o=[r[0][0],r[0][r[0].length-2]]}if(s){const r=this.getMap();for(let a=0,c=o.length;a<c;a++){const d=o[a],l=r.getPixelFromCoordinate(d),_=t[0]-l[0],f=t[1]-l[1],u=this.freehand_?1:this.snapTolerance_;if(i=Math.sqrt(_*_+f*f)<=u,i){this.finishCoordinate_=d;break}}}}return i}createOrUpdateSketchPoint_(t){this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(t):(this.sketchPoint_=new k(new M(t)),this.updateSketchFeatures_())}createOrUpdateCustomSketchLine_(t){this.sketchLine_||(this.sketchLine_=new k);const e=t.getLinearRing(0);let i=this.sketchLine_.getGeometry();i?(i.setFlatCoordinates(e.getLayout(),e.getFlatCoordinates()),i.changed()):(i=new F(e.getFlatCoordinates(),e.getLayout()),this.sketchLine_.setGeometry(i))}startDrawing_(t){const e=this.getMap().getView().getProjection(),i=R(this.geometryLayout_);for(;t.length<i;)t.push(0);this.finishCoordinate_=t,this.mode_==="Point"?this.sketchCoords_=t.slice():this.mode_==="Polygon"?(this.sketchCoords_=[[t.slice(),t.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[t.slice(),t.slice()],this.sketchLineCoords_&&(this.sketchLine_=new k(new F(this.sketchLineCoords_)));const s=this.geometryFunction_(this.sketchCoords_,void 0,e);this.sketchFeature_=new k,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(s),this.updateSketchFeatures_(),this.dispatchEvent(new P(w.DRAWSTART,this.sketchFeature_))}modifyDrawing_(t){const e=this.getMap(),i=this.sketchFeature_.getGeometry(),s=e.getView().getProjection(),o=R(this.geometryLayout_);let n,r;for(;t.length<o;)t.push(0);this.mode_==="Point"?r=this.sketchCoords_:this.mode_==="Polygon"?(n=this.sketchCoords_[0],r=n[n.length-1],this.atFinish_(e.getPixelFromCoordinate(t))&&(t=this.finishCoordinate_.slice())):(n=this.sketchCoords_,r=n[n.length-1]),r[0]=t[0],r[1]=t[1],this.geometryFunction_(this.sketchCoords_,i,s),this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(t),i.getType()==="Polygon"&&this.mode_!=="Polygon"?this.createOrUpdateCustomSketchLine_(i):this.sketchLineCoords_&&this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),this.updateSketchFeatures_()}addToDrawing_(t){const e=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection();let s,o;const n=this.mode_;n==="LineString"||n==="Circle"?(this.finishCoordinate_=t.slice(),o=this.sketchCoords_,o.length>=this.maxPoints_&&(this.freehand_?o.pop():s=!0),o.push(t.slice()),this.geometryFunction_(o,e,i)):n==="Polygon"&&(o=this.sketchCoords_[0],o.length>=this.maxPoints_&&(this.freehand_?o.pop():s=!0),o.push(t.slice()),s&&(this.finishCoordinate_=o[0]),this.geometryFunction_(this.sketchCoords_,e,i)),this.createOrUpdateSketchPoint_(t.slice()),this.updateSketchFeatures_(),s&&this.finishDrawing()}removeLastPoints_(t){if(!this.sketchFeature_)return;const e=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection(),s=this.mode_;for(let o=0;o<t;++o){let n;if(s==="LineString"||s==="Circle"){if(n=this.sketchCoords_,n.splice(-2,1),n.length>=2){this.finishCoordinate_=n[n.length-2].slice();const r=this.finishCoordinate_.slice();n[n.length-1]=r,this.createOrUpdateSketchPoint_(r)}this.geometryFunction_(n,e,i),e.getType()==="Polygon"&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(e)}else if(s==="Polygon"){n=this.sketchCoords_[0],n.splice(-2,1);const r=this.sketchLine_.getGeometry();if(n.length>=2){const a=n[n.length-2].slice();n[n.length-1]=a,this.createOrUpdateSketchPoint_(a)}r.setCoordinates(n),this.geometryFunction_(this.sketchCoords_,e,i)}if(n.length===1){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const t=this.abortDrawing_();if(!t)return;let e=this.sketchCoords_;const i=t.getGeometry(),s=this.getMap().getView().getProjection();this.mode_==="LineString"?(e.pop(),this.geometryFunction_(e,i,s)):this.mode_==="Polygon"&&(e[0].pop(),this.geometryFunction_(e,i,s),e=i.getCoordinates()),this.type_==="MultiPoint"?t.setGeometry(new ht([e])):this.type_==="MultiLineString"?t.setGeometry(new j([e])):this.type_==="MultiPolygon"&&t.setGeometry(new V([e])),this.dispatchEvent(new P(w.DRAWEND,t)),this.features_&&this.features_.push(t),this.source_&&this.source_.addFeature(t)}abortDrawing_(){this.finishCoordinate_=null;const t=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),t}abortDrawing(){const t=this.abortDrawing_();t&&this.dispatchEvent(new P(w.DRAWABORT,t))}appendCoordinates(t){const e=this.mode_,i=!this.sketchFeature_;i&&this.startDrawing_(t[0]);let s;if(e==="LineString"||e==="Circle")s=this.sketchCoords_;else if(e==="Polygon")s=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[];else return;i&&s.shift(),s.pop();for(let n=0;n<t.length;n++)this.addToDrawing_(t[n]);const o=t[t.length-1];this.addToDrawing_(o),this.modifyDrawing_(o)}extend(t){const i=t.getGeometry();this.sketchFeature_=t,this.sketchCoords_=i.getCoordinates();const s=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=s.slice(),this.sketchCoords_.push(s.slice()),this.sketchPoint_=new k(new M(s)),this.updateSketchFeatures_(),this.dispatchEvent(new P(w.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const t=[];this.sketchFeature_&&t.push(this.sketchFeature_),this.sketchLine_&&t.push(this.sketchLine_),this.sketchPoint_&&t.push(this.sketchPoint_);const e=this.overlay_.getSource();e.clear(!0),e.addFeatures(t)}updateState_(){const t=this.getMap(),e=this.getActive();(!t||!e)&&this.abortDrawing(),this.overlay_.setMap(e?t:null)}}function ut(){const h=at();return function(t,e){return h[t.getGeometry().getType()]}}function Tt(h,t){return function(e,i,s){const o=L(e[0]),n=L(e[e.length-1]),r=Math.sqrt(N(o,n));i=i||st(new O(o),h);let a=t;if(!t&&t!==0){const c=n[0]-o[0],d=n[1]-o[1];a=Math.atan2(d,c)}return nt(i,o,r,a),i}}function gt(h){switch(h){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+h)}}const xt=ft;export{xt as D,Tt as c};
