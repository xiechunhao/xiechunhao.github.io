import{_ as l,o as s,c as a,O as o}from"./chunks/framework.57763b9a.js";const u=JSON.parse('{"title":"JS基础面试题","description":"","frontmatter":{},"headers":[],"relativePath":"interview/js/advanced/index.md","filePath":"interview/js/advanced/index.md","lastUpdated":1688111209000}'),e={name:"interview/js/advanced/index.md"},n=o(`<h1 id="js基础面试题" tabindex="-1">JS基础面试题 <a class="header-anchor" href="#js基础面试题" aria-label="Permalink to &quot;JS基础面试题&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>总结的一些JS高级面试题目</p></div><h2 id="_1-作用域和作用域链" tabindex="-1">1.作用域和作用域链 <a class="header-anchor" href="#_1-作用域和作用域链" aria-label="Permalink to &quot;1.作用域和作用域链&quot;">​</a></h2><ol><li>作用域：变量起作用的区域</li><li>全局作用域（全局变量）：在函数外声明的变量，可以在任何地方使用</li><li>局部作用域（局部变量）：在函数内声明的变量，只能在函数内部使用</li><li>作用域链：变量在作用域链的访问规则：就近原则</li><li>当某个作用域访问变量，首先会从当前的作用域寻找变量，有则访问，没有就继续往上找，以此类推，直到找到作用域最顶端的（0级链）如果还没有就报错</li></ol><h2 id="_2-prototype-和-proto-区别是什么" tabindex="-1">2.prototype 和 <strong>proto</strong> 区别是什么？ <a class="header-anchor" href="#_2-prototype-和-proto-区别是什么" aria-label="Permalink to &quot;2.prototype 和 __proto__ 区别是什么？&quot;">​</a></h2><ol><li>只要是构造函数，就有一个 <code>prototype</code> 指向自己的原型对象（每个月构造函数都有prototype属性）</li><li>只要是原型对象，就有一个 <code>constructor</code> 属性指向自身对应的构造函数</li><li>只要是对象，就有一个 <code>_proto_</code> 属性指向自己的原型（原型对象也是对象）</li><li>函数也是对象</li></ol><h2 id="_3-构造函数、原型、实例" tabindex="-1">3.构造函数、原型、实例 <a class="header-anchor" href="#_3-构造函数、原型、实例" aria-label="Permalink to &quot;3.构造函数、原型、实例&quot;">​</a></h2><ol><li>每一个<code>构造函数</code>都有一个prototype执行自己的原型对象</li><li>每一个<code>原型</code>对象都有一个cunstuctor属性指向自身的构造函数</li><li>只要是<code>实例</code>，就有一个_proto_属性指向自己的原型（原型对象也是对象）</li></ol><h2 id="_4-谈谈原型的理解-如何理解原型链" tabindex="-1">4.谈谈原型的理解，如何理解原型链 <a class="header-anchor" href="#_4-谈谈原型的理解-如何理解原型链" aria-label="Permalink to &quot;4.谈谈原型的理解，如何理解原型链&quot;">​</a></h2><ol><li>什么是原型链？我们都知道对象有一个toString()方法。像我们声明的实例对象 let obj = {} 也可以找到toString()方法，但是我们什么实例的时候并没有创建这个toString()方法，那么它就会沿着_proto_向她的构造函数的 obj.prototype去找，而这里也没有，那么她就会继续沿着obj.prototype._proto_向上找，而obj.prototype._proto_最后会指定Object.prototype，那么打印Object.prototype.toString()就可以看到有这个方法。也就是我们常用验证数据类型的万能检查法的原理。这就是原理链查找，而则一层一层的链接，关系就是原型链。</li></ol><h2 id="_5-js闭包-闭包的作用-闭包使用场景" tabindex="-1">5.js闭包，闭包的作用，闭包使用场景 <a class="header-anchor" href="#_5-js闭包-闭包的作用-闭包使用场景" aria-label="Permalink to &quot;5.js闭包，闭包的作用，闭包使用场景&quot;">​</a></h2><ol><li>闭包：就是函数</li><li>作用： <ul><li>延长生命周期</li><li>在函数外部想要访问或者修改数据，只能通过内部的方法</li><li>设置安全措施，校验之内的操作，可以保证系统安全性和稳定性</li></ul></li><li>使用场景 <ul><li>沙箱模式（一种独立的空间，通常是匿名函数自调用）</li></ul></li></ol><h2 id="_6-js递归及特点" tabindex="-1">6.js递归及特点 <a class="header-anchor" href="#_6-js递归及特点" aria-label="Permalink to &quot;6.js递归及特点&quot;">​</a></h2><ol><li>递归：自己调用自己，需要有结束条件</li><li>优点： <ul><li>代码简介</li><li>在dom树使用递归，递归实现明显比循环更简单</li></ul></li><li>缺定： <ul><li>递归由于函数调用自身，需要消耗时间和空间，每次调用需要内存分配空间保存参数，返回地址及临时变量等，都需要时间，效果低</li><li>调用内存可能会溢出，每次调用会在内存中分配空间，进程容量有限，导致栈溢出，性能低</li></ul></li></ol><h2 id="_7-js深浅拷贝-有哪几种-为什么深浅拷贝-深浅拷贝的区别" tabindex="-1">7.js深浅拷贝，有哪几种，为什么深浅拷贝? 深浅拷贝的区别 <a class="header-anchor" href="#_7-js深浅拷贝-有哪几种-为什么深浅拷贝-深浅拷贝的区别" aria-label="Permalink to &quot;7.js深浅拷贝，有哪几种，为什么深浅拷贝? 深浅拷贝的区别&quot;">​</a></h2><ol><li>递归复制所有层级的属性</li><li>借用Json的parse和stringify</li><li>Object.assign()</li><li>三点运算符，又叫展开运算符（...）</li><li>为什么需要拷贝? 需要对数据进行操作，需要对原数据进行拷贝一份，不影响原数据的数据结构</li><li>区别：浅拷贝拷贝的是值，深拷贝拷贝的是地址。</li></ol><h2 id="_8-谈谈作用域-上下文和this区别" tabindex="-1">8.谈谈作用域，上下文和this区别 <a class="header-anchor" href="#_8-谈谈作用域-上下文和this区别" aria-label="Permalink to &quot;8.谈谈作用域，上下文和this区别&quot;">​</a></h2><ol><li>作用域：全局作用域和局部作用域，在局部作用域里可以访问到全局作用域，在全局作用域里不能访问局部作用域</li><li>与this关键字有关，是调用当前可执行代码的引用</li><li>this总的是指调用这个方法的对象 <ul><li>全局函数：this指向window</li><li><pre><code> -  在非严格模式下，this 指向window，在严格模式下this为undefind
</code></pre></li><li>对象方法：指向对象</li><li><pre><code> -  函数定义的位置不影响this指向，this指向只是和调用函数的对象相关
</code></pre></li><li><pre><code> -  多次嵌套的对象，内部方法的this指向离调用者最近的对象，（window也是对象，
</code></pre></li><li><pre><code>    其内部对象调用方法的this指向内部对象， 而非window）。
</code></pre></li><li>构造函数(new)：指向new创建的对象，如果没有加new会指向window</li><li>上下文模式：call、apply、bind改变this执行</li></ul></li></ol><h2 id="_9-如何正确的判断this-箭头函数的this指向是什么" tabindex="-1">9.如何正确的判断this，箭头函数的this指向是什么 <a class="header-anchor" href="#_9-如何正确的判断this-箭头函数的this指向是什么" aria-label="Permalink to &quot;9.如何正确的判断this，箭头函数的this指向是什么&quot;">​</a></h2><ol><li>我们常用函数关键字function来声明一个函数，在一个function()中，this总是指向调用这个函数的对象。但箭头函数的</li><li>this指向有点特别，它总是指向最近的外层作用域中的this所指对象</li></ol><h2 id="_10-js中什么是变量提升-什么是暂时性死区" tabindex="-1">10.JS中什么是变量提升，什么是暂时性死区 <a class="header-anchor" href="#_10-js中什么是变量提升-什么是暂时性死区" aria-label="Permalink to &quot;10.JS中什么是变量提升，什么是暂时性死区&quot;">​</a></h2><ol><li>变量提示：<code>var</code> 会存在变量提升，<code>let</code> 和 <code>const</code>声明的变量不会存在变量提升</li><li>暂时性死区：使用let命令声明的变量，改变量都是不可用的，在语法上称之为暂时性死区</li></ol><h2 id="_11-如何实现代码的复用" tabindex="-1">11.如何实现代码的复用 <a class="header-anchor" href="#_11-如何实现代码的复用" aria-label="Permalink to &quot;11.如何实现代码的复用&quot;">​</a></h2><ol><li>函数封装</li><li>继承</li><li>复制 <code>extend</code></li><li>混入 <code>mixin</code></li><li>借用 <code>apply / call</code></li></ol><h2 id="_12-怎么实现一个继承" tabindex="-1">12.怎么实现一个继承 <a class="header-anchor" href="#_12-怎么实现一个继承" aria-label="Permalink to &quot;12.怎么实现一个继承&quot;">​</a></h2><ol><li>继承：一个对象拥有另外一个对象的所有成员</li><li>第一种混入继承（遍历一个对象的成员赋值给另外一个对象）</li><li>第二种将父对象作为子对象的构造函数的原型（弊端会覆盖之前同名的属性）</li><li>第三种混入式+替换原型（解决第二种的弊端）</li></ol><h2 id="_13-防抖和节流的区别-防抖和节流的实现" tabindex="-1">13.防抖和节流的区别，防抖和节流的实现 <a class="header-anchor" href="#_13-防抖和节流的区别-防抖和节流的实现" aria-label="Permalink to &quot;13.防抖和节流的区别，防抖和节流的实现&quot;">​</a></h2><ol><li>防抖：将多次高频操作优化为只在最后一次执行，场景：用户键盘输入，只需输入一次完成后做一次输入校验即可</li><li>节流：每间隔一段时间后再执行一次，也是降低频率，将高频操作优化为低频操作。场景：滚动事件，或者resize时间，通常没隔100-500ms执行一次</li></ol><h2 id="_14-promise有几种状态-promise有什么优缺点-原理是什么" tabindex="-1">14.promise有几种状态，promise有什么优缺点，原理是什么 <a class="header-anchor" href="#_14-promise有几种状态-promise有什么优缺点-原理是什么" aria-label="Permalink to &quot;14.promise有几种状态，promise有什么优缺点，原理是什么&quot;">​</a></h2><ol><li>三种：<code>pending</code>等待，<code>resolved</code>已完成，<code>rejected</code>已拒绝</li><li>优点： <ul><li>实现了链式调用</li><li>解决回调地狱问题</li><li>更好的异常捕获机制</li></ul></li><li>缺点： <ul><li>无法取消，错误需要通过回调进行捕获</li></ul></li><li>原理：Javascript 采用回调函数(callback)来处理异步编程。从同步编程到异步回调编程有一个适应的过程，但是如果出现多层回调嵌套，也就是我们常说的厄运的回调地狱(Pyramid of Doom)，绝对是一种糟糕的编程体验。于是便有了 CommonJS 的 Promises/A 规范，用于解决回调金字塔问题。本文先介绍 Promises 相关规范，然后再通过解读一个迷你的 Promises 以加深理解。</li></ol><h2 id="_15-promise和settimeout的区别" tabindex="-1">15.promise和setTimeout的区别 <a class="header-anchor" href="#_15-promise和settimeout的区别" aria-label="Permalink to &quot;15.promise和setTimeout的区别&quot;">​</a></h2><ol><li>promise是一个宏任务，serTimeout是一个微任务</li><li>所有promise会先执行于setTimeout</li></ol><h2 id="_16-什么是宏任务-什么是微任务" tabindex="-1">16.什么是宏任务，什么是微任务 <a class="header-anchor" href="#_16-什么是宏任务-什么是微任务" aria-label="Permalink to &quot;16.什么是宏任务，什么是微任务&quot;">​</a></h2><ol><li>宏任务：<code>promise</code>，<code>ajax</code></li><li>微任务：<code>setTimeout</code>，<code>script</code>，<code>IO</code>，<code>UI</code>，<code>Rendering</code></li></ol><h2 id="_17-如何实现promise-all" tabindex="-1">17.如何实现Promise.all <a class="header-anchor" href="#_17-如何实现promise-all" aria-label="Permalink to &quot;17.如何实现Promise.all&quot;">​</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">ajax1</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">retrun</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;font-style:italic;">reject</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">api</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">login</span><span style="color:#F07178;">())</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">ajax2</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">retrun</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;font-style:italic;">reject</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">api</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">page</span><span style="color:#F07178;">())</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">all</span><span style="color:#A6ACCD;">([</span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">ajax1</span><span style="color:#A6ACCD;">()，</span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">ajax2</span><span style="color:#A6ACCD;">()])</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">((</span><span style="color:#A6ACCD;font-style:italic;">res</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">res</span><span style="color:#F07178;">[</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">]，</span><span style="color:#A6ACCD;">res</span><span style="color:#F07178;">[</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">]) </span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">))</span></span></code></pre></div><h2 id="_18-输入url到展示的过程" tabindex="-1">18.输入url到展示的过程 <a class="header-anchor" href="#_18-输入url到展示的过程" aria-label="Permalink to &quot;18.输入url到展示的过程&quot;">​</a></h2><ol><li>DNS解析</li><li>TCP三次握手</li><li>发送请求，分析url，设置请求报文</li><li>服务器返回请求的文件</li><li>浏览器渲染</li></ol><h2 id="更多面试题-参考文档" tabindex="-1">更多面试题，参考文档: <a class="header-anchor" href="#更多面试题-参考文档" aria-label="Permalink to &quot;更多面试题，参考文档:&quot;">​</a></h2><p><a href="https://blog.csdn.net/lc237423551/article/details/80010100" target="_blank" rel="noreferrer">彻底理解什么是原型链，prototype和__proto__的区别。</a></p>`,40),i=[n];function t(r,p,c,d,h,y){return s(),a("div",null,i)}const _=l(e,[["render",t]]);export{u as __pageData,_ as default};
