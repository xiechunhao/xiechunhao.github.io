import{_ as e,o,c as l,O as i}from"./chunks/framework.57763b9a.js";const p=JSON.parse('{"title":"JS基础面试题","description":"","frontmatter":{},"headers":[],"relativePath":"interview/js/base/index.md","filePath":"interview/js/base/index.md","lastUpdated":null}'),a={name:"interview/js/base/index.md"},r=i('<h1 id="js基础面试题" tabindex="-1">JS基础面试题 <a class="header-anchor" href="#js基础面试题" aria-label="Permalink to &quot;JS基础面试题&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>总结的一些JS基础面试题目</p></div><h2 id="_1-常用数组api" tabindex="-1">1.常用数组API <a class="header-anchor" href="#_1-常用数组api" aria-label="Permalink to &quot;1.常用数组API&quot;">​</a></h2><ol><li><code>String</code> 数组转为字符串</li><li><code>Join</code> 数组中间用“,”隔开【arr.Join(&#39;,&#39;) 】</li><li><code>push</code> 数组最后添加一个数据【arr.push(1)】</li><li><code>pop</code> 删除数组最后一个数据，并返回删除的值</li><li><code>concat</code> 连接两个数组，返回新数组</li><li><code>unshift</code> 数组最前面添加元素</li><li><code>shift</code> 删除数组第0位当被删除的数</li><li><code>reverse</code> 数组翻转</li><li><code>slice</code> 数组截取</li><li><code>splice</code></li><li><code>sort</code> 数组排序</li><li><code>forEach</code></li><li><code>map</code> 遍历做数据映射format</li><li><code>some</code> 有一项返回true，则整体返回true</li><li><code>every</code> 有一项返回false，则整体返回false</li><li><code>filter</code> 遍历对数据进行过滤</li><li><code>indexOf</code> 查找数组，返回下标，不存在返回-1</li><li><code>reduce</code></li></ol><h2 id="_2-数组slice-和splice-方法的区别" tabindex="-1">2.数组slice()和splice()方法的区别 <a class="header-anchor" href="#_2-数组slice-和splice-方法的区别" aria-label="Permalink to &quot;2.数组slice()和splice()方法的区别&quot;">​</a></h2><ol><li><code>slice(start,end)</code>从已有数组中返回你选择的某段数组的元素，如arr.slice(0,2)</li><li><code>splice(start,end)</code>从数组中添加或删除元素，然后返回被删除的数组元素。</li></ol><h2 id="_3-every和some区别" tabindex="-1">3.every和some区别 <a class="header-anchor" href="#_3-every和some区别" aria-label="Permalink to &quot;3.every和some区别&quot;">​</a></h2><ol><li><code>every</code> 有一项返回false，整体返回false</li><li><code>some</code> 有一项返回true，整体返回true</li></ol><h2 id="_4-map和fiter区别" tabindex="-1">4.map和fiter区别 <a class="header-anchor" href="#_4-map和fiter区别" aria-label="Permalink to &quot;4.map和fiter区别&quot;">​</a></h2><ol><li><code>map</code> 做一次统一映射，数组元素个数不变，单是按照一定条件，数组元素发生了改变，如将【aaa，bbb，ccc】转为大写的【AAA，BBB，CCC】类似format作用</li><li><code>fiter</code> 做一次过滤，数组元素个数可能发生改变，但是数组元素不会改变，如将转换大写后的【AAA，BBB，CCC】返回开头为A的数据【AAA】</li></ol><h2 id="_5-取数组的最大值" tabindex="-1">5.取数组的最大值 <a class="header-anchor" href="#_5-取数组的最大值" aria-label="Permalink to &quot;5.取数组的最大值&quot;">​</a></h2><ol><li>Math.max(...arr)</li><li>Math.max.apply(null,arr)</li><li>for循环判断</li><li>数组sort排序后去第一个arr[0]</li><li>arr.reduce((num1, num2) =&gt; { return num1 &gt; num2 ? num1 : num2 })</li></ol><h2 id="_6-类-伪-数组和数组的区别" tabindex="-1">6.类(伪)数组和数组的区别 <a class="header-anchor" href="#_6-类-伪-数组和数组的区别" aria-label="Permalink to &quot;6.类(伪)数组和数组的区别&quot;">​</a></h2><ol><li>区别：伪数组只有数组的三要素（数组元素，数组长度，数组下标，没有数组的API）</li></ol><h2 id="_7-将伪数组转换为数组" tabindex="-1">7.将伪数组转换为数组 <a class="header-anchor" href="#_7-将伪数组转换为数组" aria-label="Permalink to &quot;7.将伪数组转换为数组&quot;">​</a></h2><ol><li>遍历伪数组元素，放入真数组中</li><li>apply 改变数组指向（arr.push.apply([],伪素组)）</li></ol><h2 id="_8-for-of-for-in-foreach-map区别" tabindex="-1">8.for of，for in，forEach，map区别 <a class="header-anchor" href="#_8-for-of-for-in-foreach-map区别" aria-label="Permalink to &quot;8.for of，for in，forEach，map区别&quot;">​</a></h2><ol><li><code>for...of</code> 循环：具有 iterator 接口，就可以用for...of循环遍历它的成员(属性值)。for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象、Generator 对象，以及字符串。for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。可以中断循环。</li><li><code>for...in</code> 循环：遍历对象自身的和继承的可枚举的属性, 不能直接获取属性值。可以中断循环。</li><li><code>forEach</code> 只能遍历数组，不能中断，没有返回值(或认为返回值是undefined)。</li><li><code>map</code> 只能遍历数组，不能中断，返回值是修改后的数组。</li></ol><h2 id="_9-js数据类型-基本类型有哪些-基本数据类型和复杂-引用-数据类型存储方式有什么区别" tabindex="-1">9.JS数据类型，基本类型有哪些，基本数据类型和复杂(引用)数据类型存储方式有什么区别 <a class="header-anchor" href="#_9-js数据类型-基本类型有哪些-基本数据类型和复杂-引用-数据类型存储方式有什么区别" aria-label="Permalink to &quot;9.JS数据类型，基本类型有哪些，基本数据类型和复杂(引用)数据类型存储方式有什么区别&quot;">​</a></h2><ol><li>基本数据类型：<code>string</code>，<code>number</code>，<code>boolean</code>，<code>undefined</code>，<code>null</code></li><li>复杂数据类型：<code>Object</code>，<code>Array</code>，<code>Date</code>，<code>Math</code>，<code>Function</code>，<code>String</code>，<code>Number</code>，<code>Boolean</code>，<code>RegExp</code></li><li>区别： <ul><li>基本类型栈中存储的是数据，赋值拷贝的是数据，修改拷贝后的数据对原数据没有影响</li><li>复杂数据类型栈中存储的是地址，复杂拷贝的是地址，修改拷贝后的数据对原数据有影响</li></ul></li></ol><h2 id="_10-判断一个变量是否是数组" tabindex="-1">10.判断一个变量是否是数组 <a class="header-anchor" href="#_10-判断一个变量是否是数组" aria-label="Permalink to &quot;10.判断一个变量是否是数组&quot;">​</a></h2><ol><li>arr instanceof Array</li><li>Array.isArray(arr)</li><li>Object.prototype.toString.call(arr) === &#39;[object Array]&#39;</li></ol><h2 id="_11-js类型判断" tabindex="-1">11.JS类型判断 <a class="header-anchor" href="#_11-js类型判断" aria-label="Permalink to &quot;11.JS类型判断&quot;">​</a></h2><ol><li><code>typeof</code> 常用【object（Array属于object子类）】object</li><li><code>instanceof</code> 了解【arr instanceof Array】true</li><li><code>Object.prototype.toString.call()</code> 最靠谱【Object.prototype.toString.call()】[object Array]</li><li><code>constructor</code> 比较常用【arr.constructor】Array</li><li><code>toString()</code> 了解【toString(arr)】[object Array]</li></ol><h2 id="_12-null和undefind区别" tabindex="-1">12.null和undefind区别 <a class="header-anchor" href="#_12-null和undefind区别" aria-label="Permalink to &quot;12.null和undefind区别&quot;">​</a></h2><ol><li><code>null</code> 空值，在任何时候变量不会主动变为null，除非程序员自动设置为null值</li><li><code>undefind</code> 未定义，变量只有声明，没有赋值时候就会出现undefind</li><li>区别：某种意义上，undefind与null都是代表空值，但是会相等吗？会全等吗？ <ul><li>会相等，值是相等</li><li>不会全等，类型不是全等的，一个是Object类型，一个是数据类型</li></ul></li></ol><h2 id="_13-和-区别" tabindex="-1">13.== 和 === 区别 <a class="header-anchor" href="#_13-和-区别" aria-label="Permalink to &quot;13.== 和 === 区别&quot;">​</a></h2><ol><li><code>==</code> 判断相等，非严格匹配，会类型隐式转换，后的值进行判断</li><li><code>===</code> 判断全等，严格匹配，不会进行类型转换，必须要求数据类型和值一致。</li></ol><h2 id="_14-var-let-const的区别" tabindex="-1">14.var，let，const的区别 <a class="header-anchor" href="#_14-var-let-const的区别" aria-label="Permalink to &quot;14.var，let，const的区别&quot;">​</a></h2><ol><li><code>var</code> 变量，存在变量提升</li><li><code>let</code> 变量，局部作用域，不会存在变量提示</li><li><code>const</code> 常量，一旦设置不允许修改</li></ol><h2 id="_15-cookie-session-sessionstorage-localstrorage" tabindex="-1">15.cookie，session，sessionStorage，localStrorage <a class="header-anchor" href="#_15-cookie-session-sessionstorage-localstrorage" aria-label="Permalink to &quot;15.cookie，session，sessionStorage，localStrorage&quot;">​</a></h2><ol><li><code>cookie</code> 存放在浏览器端，可以设置有效过期时间，数据不能超过4K</li><li><code>session</code> 存放在服务器端，可以设置有效过期时间，当访问过于频繁会占用服务器性能，考虑减去服务器压力，采用cookie</li><li><code>sessionStrorage</code> 同源窗口中，sessionStrorage会一直存在，直到手动关闭</li><li><code>localStrorgae</code> 同源窗口共享，关闭不会消失，除非手动消除</li></ol><h2 id="_16-es6模块化" tabindex="-1">16.ES6模块化 <a class="header-anchor" href="#_16-es6模块化" aria-label="Permalink to &quot;16.ES6模块化&quot;">​</a></h2><ol><li>模块化主要有三种方案，<code>CommonJS</code>，<code>ES6</code>，<code>AMD/CMD</code></li><li>CommonJS：module.exports / require(&#39;文件名&#39;)</li><li>ES6的模块化：export / import</li></ol><h2 id="_17-定义函数的方法" tabindex="-1">17.定义函数的方法 <a class="header-anchor" href="#_17-定义函数的方法" aria-label="Permalink to &quot;17.定义函数的方法&quot;">​</a></h2><ol><li>函数表达式 let fun = new Function(){}</li><li>函数声明 let function fun(){}</li><li>匿名函数 function fun(){}</li></ol><h2 id="_18-script-引入方式" tabindex="-1">18.script 引入方式 <a class="header-anchor" href="#_18-script-引入方式" aria-label="Permalink to &quot;18.script 引入方式&quot;">​</a></h2><ol><li><code>html</code> 静态引入</li><li><code>js</code> 动态引入</li><li><code>&lt;script defer&gt;</code> 延迟加载，元素解析完成后只需</li><li><code>&lt;script async&gt;</code> 异步加载，但执行时会阻塞元素渲染</li></ol>',38),c=[r];function d(t,n,s,h,u,f){return o(),l("div",null,c)}const _=e(a,[["render",d]]);export{p as __pageData,_ as default};
